<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基本语法语句&#x3D;&#x3D;JavaScript 程序的执行单位为行，也就是一行一行地执行。&#x3D;&#x3D; 一般情况下，每一行就是一个语句。 语句是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a &#x3D; 1 + 3;  1 + 3 叫做表达式，指一个为了得到返回值的计算式。&#x3D;&#x3D;语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。&#x3D;&#x3D; 变">
<meta property="og:type" content="website">
<meta property="og:title" content="JavaScript">
<meta property="og:url" content="http://yoursite.com/JavaScript/index.html">
<meta property="og:site_name" content="Albert Guo">
<meta property="og:description" content="基本语法语句&#x3D;&#x3D;JavaScript 程序的执行单位为行，也就是一行一行地执行。&#x3D;&#x3D; 一般情况下，每一行就是一个语句。 语句是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。 1var a &#x3D; 1 + 3;  1 + 3 叫做表达式，指一个为了得到返回值的计算式。&#x3D;&#x3D;语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。&#x3D;&#x3D; 变">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-06-29T09:50:28.000Z">
<meta property="article:modified_time" content="2020-07-20T11:08:43.393Z">
<meta property="article:author" content="Albert Guo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/JavaScript/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript | Albert Guo
</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Albert Guo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-bars fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-address-card fa-fw"></i>简介</a>

  </li>
        <li class="menu-item menu-item-webpack">

    <a href="/webpack/" rel="section"><i class="fa fa-bookmark fa-fw"></i>webpack</a>

  </li>
        <li class="menu-item menu-item-javascript">

    <a href="/JavaScript/" rel="section"><i class="fa fa-bookmark fa-fw"></i>ECMAScript 5.1</a>

  </li>
        <li class="menu-item menu-item-ecmascript6">

    <a href="/ECMAScript6/" rel="section"><i class="fa fa-bookmark fa-fw"></i>ECMAScript 6</a>

  </li>
        <li class="menu-item menu-item-react">

    <a href="/react/" rel="section"><i class="fa fa-bookmark fa-fw"></i>React</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">JavaScript
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>==JavaScript 程序的执行单位为行，也就是一行一行地执行。== 一般情况下，每一行就是一个语句。</p>
<p>语句是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><code>1 + 3</code> 叫做表达式，指一个为了得到返回值的计算式。==语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。==</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>注意，==JavaScript 的变量名区分大小写，A 和 a 是两个不同的变量。==</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>==JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提升后</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。==JavaScript 语言的标识符对大小写敏感，所以 a 和 A 是两个不同的标识符。==</p>
<p>标识符命名规则：</p>
<ul>
<li>第一个字符，可以是任意 <code>Unicode</code>。</li>
<li>字母（包括英文字母和其他语言的字母），以及美元符号 $ 和下划线 _ 。</li>
<li>第二个字符及后面的字符，除了 <code>Unicode</code> 字母、美元符号和下划线，还可以用数字 <code>0-9</code>。</li>
</ul>
<p>JavaScript 有一些保留字，不能用作标识符：<code>arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield</code>。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：</p>
<ul>
<li>一种是单行注释，用 <code>//</code> 起头；</li>
<li>另一种是多行注释，放在 <code>/*</code> 和 <code>*/</code> 之间。</li>
</ul>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”。==对于 var 命令来说，JavaScript 的区块不构成单独的作用域。==</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a>if 结构</h3><p><code>if</code> 结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，<code>true</code> 表示真，<code>false</code> 表示伪。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔值)&#123;</span><br><span class="line">  语句;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="if-…-else-结构"><a href="#if-…-else-结构" class="headerlink" title="if … else 结构"></a>if … else 结构</h3><p><code>if</code> 代码块后面，还可以跟一个 <code>else</code> 代码块，表示不满足条件时，所要执行的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m === <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="comment">// 满足条件时，执行的语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不满足条件时，执行的语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h3><p>多个 <code>if ... else</code> 连在一起使用的时候，可以转为使用更方便的 <code>switch</code> 结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"banana"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"apple"</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码根据变量 <code>fruit</code> 的值，选择执行相应的 <code>case</code>。如果所有 <code>case</code> 都不符合，则执行最后的 default 部分。==需要注意的是，每个 <code>case</code> 代码块内部的 <code>break</code> 语句不能少，否则会接下去执行下一个 <code>case</code> 代码块，而不是跳出 <code>switch</code> 结构。==</p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ? :"></a>三元运算符 ? :</h3><p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）<code>x ? x : x</code>，也可以用于逻辑判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(条件) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>==上面代码中，如果“条件”为 <code>true</code>，则返回“表达式1”的值，否则返回“表达式2”的值。==</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式。</p>
<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><code>while</code> 语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><code>for</code> 语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化表达式; 条件; 递增表达式) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code> 语句后面的括号里面，有三个表达式：</p>
<ul>
<li>初始化表达式：确定循环变量的初始值，只在循环开始时执行一次。</li>
<li>条件表达式：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li>
<li>递增表达式：每轮循环的最后一个操作，通常用来递增循环变量。</li>
</ul>
<h3 id="do-…-while-循环"><a href="#do-…-while-循环" class="headerlink" title="do … while 循环"></a>do … while 循环</h3><p><code>do ... while</code> 循环与 <code>while</code> 循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>

<p>不管条件是否为真，<code>do ... while</code> 循环至少运行一次，这是这种结构最大的特点。另外，==while 语句后面的分号注意不要省略。==</p>
<h3 id="break-语句和-continue-语句"><a href="#break-语句和-continue-语句" class="headerlink" title="break 语句和 continue 语句"></a>break 语句和 continue 语句</h3><p><code>break</code> 语句和 <code>continue</code> 语句都具有跳转作用，可以让代码不按既有的顺序执行。适用于 <code>while 、for</code> 循环等语句。</p>
<p>==<code>break</code>语句用于跳出代码块或循环。==</p>
<p>==<code>continue</code> 语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。==</p>
<hr>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h2><p>JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。（ES6 又新增了第七种 <code>Symbol</code> 类型的值）</p>
<ul>
<li>数值（<code>number</code>）：整数和小数（比如 <code>1</code> 和 <code>3.14</code>）；</li>
<li>字符串（<code>string</code>）：文本（比如 <code>&#39;Hello World&#39;</code>）；</li>
<li>布尔值（<code>boolean</code>）：表示真伪的两个特殊值，即 <code>true</code>（真）和 <code>false</code>（假）；</li>
<li><code>undefined</code>：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值；</li>
<li><code>null</code>：表示空值，即此处的值为空；</li>
<li><code>Symbol</code>：表示独一无二的值（ES6 新增）；</li>
<li>对象（<code>object</code>）：各种值组成的集合。</li>
</ul>
<p>对象是最复杂的数据类型，又可以分成三个子类型。</p>
<ul>
<li>狭义的对象（<code>object</code>）</li>
<li>数组（<code>array</code>）</li>
<li>函数（<code>function</code>）</li>
</ul>
<h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p>
<ul>
<li><code>typeof</code> 运算符</li>
<li><code>instanceof</code> 运算符</li>
<li><code>Object.prototype.toString</code> 方法</li>
</ul>
<p><code>typeof</code> 运算符可以返回一个值的数据类型。</p>
<p>==数值、字符串、布尔值分别返回 <code>number、string、boolean</code>；函数返回 <code>function</code>、<code>undefined</code> 返回 <code>undefined</code>、对象返回 <code>object</code>、<code>null</code> 返回 <code>object</code>（历史原因）。==</p>
<h2 id="null-undefined-和布尔值"><a href="#null-undefined-和布尔值" class="headerlink" title="null, undefined 和布尔值"></a>null, undefined 和布尔值</h2><h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><p><code>null</code> 与 <code>undefined</code> 都可以表示“没有”，含义非常相似。将一个变量赋值为 <code>undefined</code> 或 <code>null</code>，老实说，语法效果几乎没区别。</p>
<p><code>null</code> 表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入 <code>null</code>，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入 <code>null</code>，表示未发生错误。==<code>undefined</code> 表示变量“未定义”。==</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值代表“真”和“假”两个状态。“真”用关键字 <code>true</code> 表示，“假”用关键字 <code>false</code> 表示。==布尔值只有这两个值。==</p>
<p>下列运算符会返回布尔值：</p>
<ul>
<li>前置逻辑运算符： <code>! (Not)</code></li>
<li>相等运算符：<code>===，!==，==，!=</code></li>
<li>比较运算符：<code>&gt;，&gt;=，&lt;，&lt;=</code></li>
</ul>
<p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 <code>false</code>，其他值都视为 <code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot; 或 &#39;&#39;</code>（空字符串）</li>
</ul>
<h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><p>JavaScript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，<code>1</code> 与 <code>1.0</code> 是相同的，是同一个数。由于浮点数不是精确的值，所以==涉及小数的比较和运算要特别小心。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.3</span> / <span class="number">0.1</span></span><br><span class="line"><span class="comment">// 2.9999999999999996</span></span><br><span class="line"></span><br><span class="line">(<span class="number">0.3</span> - <span class="number">0.2</span>) === (<span class="number">0.2</span> - <span class="number">0.1</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p><code>NaN</code> 是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p>
<ul>
<li>==<code>NaN</code> 不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于 Number；==</li>
<li>==<code>NaN</code> 不等于任何值，包括它本身；==</li>
<li>==<code>NaN</code> 在布尔运算时被当作 <code>false</code>；==</li>
<li>==<code>NaN</code> 与任何数（包括它自己）的运算，得到的都是 <code>NaN</code>。==</li>
</ul>
<h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p><code>parseInt</code> 全局方法用于将字符串转为整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'   81'</span>) <span class="comment">// 81</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1.23</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1.23'</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'8a'</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12**'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15e2'</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'15px'</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'.3'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'+1'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p><code>parseFloat</code> 全局方法用于将一个字符串转为浮点数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14'</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.14more non-digit characters'</span>) <span class="comment">// 3.14</span></span><br><span class="line"><span class="built_in">parseFloat</span>([]) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'FF2'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">''</span>) <span class="comment">// NaN（注意：parseFloat 会将空字符串转为 NaN）</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'123.45#'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p><code>isNaN</code> 方法可以用来判断一个值是否为 <code>NaN</code>。</p>
<p>可以利用 <code>NaN</code> 为唯一不等于自身的值的这个特点，进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="string">"abc"</span></span><br></pre></td></tr></table></figure>


<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>反斜杠 <code>\</code> 在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p>
<p>需要用反斜杠转义的特殊字符，主要有下面这些。</p>
<ul>
<li>\0 ：null（\u0000）</li>
<li>\b ：后退键（\u0008）</li>
<li>\f ：换页符（\u000C）</li>
<li>\n ：换行符（\u000A）</li>
<li>\r ：回车键（\u000D）</li>
<li>\t ：制表符（\u0009）</li>
<li>\v ：垂直制表符（\u000B）</li>
<li>\‘ ：单引号（\u0027）</li>
<li>\“ ：双引号（\u0022）</li>
<li>\\ ：反斜杠（\u005C）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1\n2'</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>


<h3 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line">s[<span class="number">0</span>] <span class="comment">// "h"</span></span><br><span class="line">s[<span class="number">1</span>] <span class="comment">// "e"</span></span><br><span class="line">s[<span class="number">4</span>] <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接对字符串使用方括号运算符</span></span><br><span class="line"><span class="string">'hello'</span>[<span class="number">1</span>] <span class="comment">// "e"</span></span><br></pre></td></tr></table></figure>

<p>但是，==字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。==</p>
<h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p><code>length</code> 属性返回字符串的长度，该属性也是无法改变的。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>==对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'Hello'</span>,</span><br><span class="line">  bar: <span class="string">'World'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h3><p>==对象的所有键名都是字符串（ES6 又引入了 <code>Symbol</code> 值也可以作为键名），所以加不加引号都可以。==</p>
<p>==对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。==</p>
<h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p>==如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"></span><br><span class="line">o1.a = <span class="number">1</span>;</span><br><span class="line">o2.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">o2.b = <span class="number">2</span>;</span><br><span class="line">o1.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;</span><br></pre></td></tr></table></figure>


<p>JavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含 <code>foo</code>  属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签 <code>foo</code>，指向表达式 <code>123</code>。</p>
<p>为了避免这种歧义，JavaScript 引擎的做法是，==如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>==如果要解释为对象，最好在大括号前加上圆括号。== 因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;) <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><h4 id="属性读取"><a href="#属性读取" class="headerlink" title="属性读取"></a>属性读取</h4><p>==读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: <span class="string">'Hello World'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// "Hello World"</span></span><br><span class="line">obj[<span class="string">'p'</span>] <span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure>


<p>==注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。==</p>
<h4 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h4><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo = <span class="string">'Hello'</span>;</span><br><span class="line">obj[<span class="string">'bar'</span>] = <span class="string">'World'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h4><p>查看一个对象本身的所有属性，可以使用 <code>Object.keys</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  key1: <span class="number">1</span>,</span><br><span class="line">  key2: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj);   <span class="comment">// ['key1', 'key2']</span></span><br></pre></td></tr></table></figure>

<h4 id="属性的删除：delete-命令"><a href="#属性的删除：delete-命令" class="headerlink" title="属性的删除：delete 命令"></a>属性的删除：delete 命令</h4><p><code>delete</code> 命令用于删除对象的属性，删除成功后返回 <code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// ["p"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br><span class="line">obj.p <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>==注意，删除一个不存在的属性，<code>delete</code> 不报错，而且返回 <code>true</code>。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h4><p>==<code>in</code> 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回 <code>true</code>，否则返回 <code>false</code>。== 它的左边是一个字符串，表示属性名，右边是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">'p'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>==<code>in</code> 运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。== 可以使用对象的 <code>hasOwnProperty</code> 方法判断一下，是否为对象自身的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'toString'</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'toString'</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性的遍历：for…in-循环"><a href="#属性的遍历：for…in-循环" class="headerlink" title="属性的遍历：for…in 循环"></a>属性的遍历：for…in 循环</h4><p><code>for...in</code> 循环用来遍历一个对象的全部属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'键名：'</span>, i);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'键值：'</span>, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 键名： a</span></span><br><span class="line"><span class="comment">// 键值： 1</span></span><br><span class="line"><span class="comment">// 键名： b</span></span><br><span class="line"><span class="comment">// 键值： 2</span></span><br><span class="line"><span class="comment">// 键名： c</span></span><br><span class="line"><span class="comment">// 键值： 3</span></span><br></pre></td></tr></table></figure>

<p><code>for...in</code> 循环有两个使用注意点。</p>
<ul>
<li>==它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。==</li>
<li>==它不仅遍历对象自身的属性，还遍历继承的属性。==</li>
</ul>
<p>如果继承的属性是可遍历的，那么就会被 <code>for...in</code> 循环遍历到。但是，==一般情况下，都是只想遍历对象自身的属性，所以使用 <code>for...in</code>  的时候，应该结合使用 <code>hasOwnProperty</code> 方法，在循环内部判断一下，某个属性是否为对象自身的属性。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">'老张'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="keyword">if</span> (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p>
<h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p>JavaScript 有三种声明函数的方法。</p>
<ul>
<li>function 命令</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数表达式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Function 构造函数（几乎不用）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(</span><br><span class="line">  <span class="string">'x'</span>,</span><br><span class="line">  <span class="string">'y'</span>,</span><br><span class="line">  <span class="string">'return x + y'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。==</p>
<h3 id="圆括号运算符，return-语句"><a href="#圆括号运算符，return-语句" class="headerlink" title="圆括号运算符，return 语句"></a>圆括号运算符，return 语句</h3><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>==函数体内部的 <code>return</code> 语句，表示返回。JavaScript 引擎遇到 <code>return</code> 语句，就直接返回 <code>return</code> 后面的那个表达式的值，后面即使还有语句，也不会得到执行。== 也就是说，<code>return</code> 语句所带的那个表达式，就是函数的返回值。<code>return</code> 语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回 <code>undefined</code>。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>==函数可以调用自身，这就是递归。== 下面就是通过递归，计算斐波那契数列的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> fib(num - <span class="number">2</span>) + fib(num - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(<span class="number">6</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h3 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h3><p>==JavaScript 引擎将函数名视同变量名，所以采用 <code>function</code> 命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。== 所以，下面的代码不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果采用赋值语句定义函数，JavaScript 就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面的代码等同于下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f;</span><br><span class="line">f();</span><br><span class="line">f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>函数的 <code>name</code> 属性返回函数的名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">f1.name <span class="comment">// "f1"</span></span><br></pre></td></tr></table></figure>

<h4 id="length-属性-1"><a href="#length-属性-1" class="headerlink" title="length 属性"></a>length 属性</h4><p>函数的 <code>length</code> 属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b</span>) </span>&#123;&#125;</span><br><span class="line">f.length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>函数的 <code>toString</code> 方法返回一个字符串，内容是函数的源码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line"><span class="comment">// function f() &#123;</span></span><br><span class="line"><span class="comment">//  a();</span></span><br><span class="line"><span class="comment">//  b();</span></span><br><span class="line"><span class="comment">//  c();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>对于那些原生的函数，<code>toString()</code> 方法返回 <code>function (){[native code]}</code>。</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>作用域指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：==一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本笔记不涉及。==</p>
<p>==对于顶层函数来说，函数外部声明的变量就是全局变量，它可以在函数内部读取。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>==在函数内部定义的变量，外部无法读取，称为“局部变量”。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v <span class="comment">// ReferenceError: v is not defined</span></span><br></pre></td></tr></table></figure>

<p>==函数内部定义的变量，会在该作用域内覆盖同名全局变量。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 2</span></span><br><span class="line">v <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>==对于 var 命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h4><p>==与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var 命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    tmp = x - <span class="number">100</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h4><p>函数本身也是一个值，也有自己的作用域。==它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p>
<p>函数参数不是必需的，JavaScript 允许省略参数。但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入 <code>undefined</code>。</p>
<h4 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h4><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">  p = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">f(p);</span><br><span class="line"></span><br><span class="line">p <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：==全局作用域和函数作用域。函数内部可以直接读取全局变量，函数外部无法读取函数内部声明的变量。==</p>
<p>如果需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>

<p>由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p>
<p>闭包的最大用处有两个：</p>
<ul>
<li>可以读取函数内部的变量；</li>
<li>让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在；</li>
<li>封装对象的私有属性和私有方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">'张三'</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>==外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。== 因此不能滥用闭包，否则会造成网页的性能问题。</p>
<h3 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h3><p>在 JavaScript 中，圆括号 <code>()</code> 是一种运算符，跟在函数名之后，表示调用该函数。比如，<code>print()</code> 就表示调用 <code>print</code> 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>

<p>==注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。==</p>
<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。</p>
<p>它的目的有两个：</p>
<ul>
<li>一是不必为函数命名，避免了污染全局变量；</li>
<li>二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">var</span> tmp = newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二（推荐：因为完全避免了污染全局变量）</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h1><h2 id="JavaScript-5-1"><a href="#JavaScript-5-1" class="headerlink" title="JavaScript 5.1"></a>JavaScript 5.1</h2><ul>
<li><code>var</code></li>
<li><code>function</code></li>
</ul>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul>
<li><code>var</code></li>
<li><code>function</code></li>
<li><code>const</code></li>
<li><code>let</code></li>
<li><code>import</code></li>
<li><code>class</code></li>
</ul>
<hr>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="取反运算符（-）"><a href="#取反运算符（-）" class="headerlink" title="取反运算符（!）"></a>取反运算符（!）</h2><p>将布尔值变为反向值，==以下 6 个值取反后为 <code>true</code>，其他值都为 <code>false</code>。==</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>NaN</code></li>
<li><code>0</code></li>
<li><code>false</code></li>
<li><code>空字符串(&#39;&#39;)</code></li>
</ul>
<p>注意：==空数组 [ ]、空对象 { } 这些转为布尔值都为 true，取反为 false。==</p>
<h2 id="或运算符（a-b）"><a href="#或运算符（a-b）" class="headerlink" title="或运算符（a || b）"></a>或运算符（a || b）</h2><p>如果 a 返回的布尔值为 <code>true</code>，返回 a 的值，不再对 b 求值；如果 a 返回的布尔值为 <code>false</code>，直接返回 b 的值。（注意：==这里返回的是 a 或者 b 表达式的结果值，而不是布尔值。==）</p>
<h2 id="且运算符（a-amp-amp-b）"><a href="#且运算符（a-amp-amp-b）" class="headerlink" title="且运算符（a &amp;&amp; b）"></a>且运算符（a &amp;&amp; b）</h2><p>如果 a 返回的布尔值为 <code>true</code>，则返回 b 的值，如果 a 返回的布尔值是 <code>false</code>，则直接返回 a 的值。（注意：==这里返回的是 a 或者 b 表达式的结果值，而不是布尔值。==）</p>
<h2 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h2><ul>
<li><code>==</code> 比较两个值是否相等，类型可以不同。</li>
<li><code>===</code> 比较两个值是否为“同一个值”，类型必须相同。</li>
</ul>
<h2 id="三元条件运算符（a-b-c）"><a href="#三元条件运算符（a-b-c）" class="headerlink" title="三元条件运算符（a ? b : c）"></a>三元条件运算符（a ? b : c）</h2><p>如果第一个表达式 <code>a</code> 的布尔值为 <code>true</code>，则返回 <code>b</code> 表达式的值，否则返回 <code>c</code> 表达式的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ? b : c <span class="comment">// a 如果返回 true ，则执行 b ，否则执行 c</span></span><br></pre></td></tr></table></figure>

<h2 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h2><p>将运算符首先转为数值，然后加上 <code>1</code> 或者减去 <code>1</code>。它们会修改原始变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">++x <span class="comment">// 2</span></span><br><span class="line">x <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">--x <span class="comment">// 1</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x++ <span class="comment">// 1</span></span><br><span class="line">++y <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><ul>
<li><code>Number()</code></li>
<li><code>String()</code></li>
<li><code>Boolean()</code></li>
</ul>
<h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><p>自动转换具有不确定性，而且不易除错，==建议在预期为布尔值、数值、字符串的地方，全部使用 Boolean、Number 和 String 函数进行显式转换。==</p>
<h3 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h3><p>除了 <code>undefined、null、+0、0</code> 或者 <code>-0、NaN</code>、空字符串 <code>&quot;&quot;</code>，其它都会自动转换为 <code>true</code>。</p>
<h3 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h3><p>字符串加法运算时候，当一个值为字符串，另一个值为非字符串，则后者会自动转换为字符串。</p>
<h3 id="自动转换为数值"><a href="#自动转换为数值" class="headerlink" title="自动转换为数值"></a>自动转换为数值</h3><p>除了加法运算符（<code>+</code>）有可能会运算子转化为字符串，其它运算符都会把运算子自动转换为数值。</p>
<hr>
<h1 id="String-常见用法"><a href="#String-常见用法" class="headerlink" title="String 常见用法"></a>String 常见用法</h1><h2 id="String-prototype-slice"><a href="#String-prototype-slice" class="headerlink" title="String.prototype.slice()"></a>String.prototype.slice()</h2><p>==用于从原来字符串中提取字符串并返回，不会改变原来的字符串。== 第一个参数是字符串开始位置，第二个参数是字符串结束位置（不包含该位置）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'JavaScript'</span>.slice(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">// "Java"</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-substring-、String-prototype-substr"><a href="#String-prototype-substring-、String-prototype-substr" class="headerlink" title="String.prototype.substring()、String.prototype.substr()"></a>String.prototype.substring()、String.prototype.substr()</h2><p>用法基本和 <code>String.prototype.slice()</code> 一样的，一般建议用 <code>slice</code> 方法即可。</p>
<h2 id="String-prototype-indexOf-、String-prototype-lastIndexOf"><a href="#String-prototype-indexOf-、String-prototype-lastIndexOf" class="headerlink" title="String.prototype.indexOf()、String.prototype.lastIndexOf()"></a>String.prototype.indexOf()、String.prototype.lastIndexOf()</h2><p><code>indexOf</code> 方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回 -1 就表示不匹配。 <code>lastIndexOf</code> 用法和 <code>indexOf</code> 基本一样，区别在于从字符串的尾部，向前查找。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span>.indexOf(<span class="string">'o'</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="string">'JavaScript'</span>.indexOf(<span class="string">'script'</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>支持第二个参数，表示从该位置向后查询。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello world'</span>.indexOf(<span class="string">'o'</span>, <span class="number">6</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a>String.prototype.trim()</h2><p>去除字符串两端的空格，返回新的字符串，==不改变原字符串。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'  hello world  '</span>.trim() <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-toLowerCase-、toUpperCase"><a href="#String-prototype-toLowerCase-、toUpperCase" class="headerlink" title="String.prototype.toLowerCase()、toUpperCase()"></a>String.prototype.toLowerCase()、toUpperCase()</h2><p><code>toLowerCase</code> 方法用于将一个字符串全部转为小写，<code>toUpperCase</code> 则是全部转为大写。==它们都返回一个新字符串，不改变原字符串。==</p>
<h2 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h2><p>用于确定字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到，返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'gkasjdlfs'</span>.match(<span class="string">'s'</span>) <span class="comment">// ["s", index: 3, input: "gkasjdlfs", groups: undefined]</span></span><br><span class="line"><span class="string">'guopengsong'</span>.match(<span class="string">'d'</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prorotype-search"><a href="#String-prorotype-search" class="headerlink" title="String.prorotype.search()"></a>String.prorotype.search()</h2><p><code>search</code> 方法的用法基本等同于 <code>match</code>，但是返回的是匹配的第一个索引位置。如果没有找到匹配，返回 <code>-1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'asdfghjkl'</span>.search(<span class="string">'d'</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="string">'asdfsdf'</span>.search(<span class="string">'fgse'</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h2><p><code>replace</code> 方法用于替换匹配的字符串，一般情况下只替换第一个匹配（除非使用带有 <code>g</code> 修饰符的正则表达式）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'asdfsadf'</span>.replace(<span class="string">'a'</span>,<span class="string">'---'</span>) <span class="comment">// "---sdfsadf"</span></span><br></pre></td></tr></table></figure>

<h2 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h2><p>==<code>split</code> 方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a|b|c'</span>.split(<span class="string">'|'</span>) <span class="comment">// ['a','b','c']</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Number-常见用法"><a href="#Number-常见用法" class="headerlink" title="Number 常见用法"></a>Number 常见用法</h1><h2 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h2><p>将一个数值转化为字符串形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).toString() <span class="comment">// '10'</span></span><br></pre></td></tr></table></figure>

<h2 id="Number-prototype-toFiexd"><a href="#Number-prototype-toFiexd" class="headerlink" title="Number.prototype.toFiexd()"></a>Number.prototype.toFiexd()</h2><p><code>toFiexd()</code> 方法先将一个数值转化为指定位数的小数，然后返回这个小数对应的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.005</span>.toFixed(<span class="number">2</span>) <span class="comment">// "10.01"</span></span><br></pre></td></tr></table></figure>

<h2 id="全局方法-parseInt"><a href="#全局方法-parseInt" class="headerlink" title="全局方法 parseInt()"></a>全局方法 parseInt()</h2><p>用于将字符串转为整数，会删除小数部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'123'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'3.4'</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="全局方法-parseFloat"><a href="#全局方法-parseFloat" class="headerlink" title="全局方法 parseFloat()"></a>全局方法 parseFloat()</h2><p><code>parseFloat()</code> 方法用于将一个字符串转为浮点数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'3.244'</span>) <span class="comment">// 3.244</span></span><br></pre></td></tr></table></figure>

<h2 id="NaN、全局方法-isNaN"><a href="#NaN、全局方法-isNaN" class="headerlink" title="NaN、全局方法 isNaN()"></a>NaN、全局方法 isNaN()</h2><p><code>NaN</code> 特殊值，表示“非数值”，出现在将字符串解析成数值出错的场合。</p>
<p><code>isNaN</code> 方法可以用来判断一个值是否为 <code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">213</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Array-常见用法"><a href="#Array-常见用法" class="headerlink" title="Array 常见用法"></a>Array 常见用法</h1><p><code>Array</code> 是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p>
<h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h2><p>返回一个布尔值，表示参数是否为数组，可以弥补 <code>typeof</code> 运算符的不足。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// 'object'</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h2><p>==<code>push</code> 方法用于在数组的末端添加一个或者多个元素，并且返回新元素后的数组长度。注意，该方法会改变原数组。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr.push(<span class="number">3</span>) <span class="comment">// 1</span></span><br><span class="line">arr.push(<span class="string">'a'</span>,<span class="string">'b'</span>) <span class="comment">// 3</span></span><br><span class="line">arr <span class="comment">// [3,'a','b']</span></span><br></pre></td></tr></table></figure>

<h2 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h2><p>==<code>pop</code> 方法用于删除数组的最后一个元素，并且返回该元素。注意，该方法会改变原数组。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">arr.pop() <span class="comment">// 'c'</span></span><br><span class="line">arr <span class="comment">// ['a','b']</span></span><br></pre></td></tr></table></figure>


<h2 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h2><p>==<code>shift</code> 方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">arr.shift() <span class="comment">// 'a'</span></span><br><span class="line">a <span class="comment">// ['b','c']</span></span><br></pre></td></tr></table></figure>

<h2 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h2><p>==<code>unshift</code> 方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">a.unshift(<span class="string">'x'</span>); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// ['x','a','b','c']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'c'</span>,<span class="string">'d'</span>];</span><br><span class="line">arr.unshift(<span class="string">'a'</span>,<span class="string">'b'</span>) <span class="comment">// 4</span></span><br><span class="line">arr <span class="comment">// ['a','b','c','d']</span></span><br></pre></td></tr></table></figure>

<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p><code>join</code> 方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。==该方法不改变原数组。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line">a.join(<span class="string">'--'</span>) <span class="comment">// 'a--b--c'</span></span><br></pre></td></tr></table></figure>

<h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h2><p><code>concat</code> 方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，不改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line"><span class="keyword">var</span> b = [<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">a.concat(b) <span class="comment">// ['a','b','c','d']</span></span><br></pre></td></tr></table></figure>

<h2 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h2><p><code>slice</code> 方法用户提取目标数组中的一部分，==返回一个新数组，原数组不变。==</p>
<p>它第一个参数为起始位置（从0开始），第二个参数为终止位置（包含该元素本身）。如果第二个参数省略，则一直返回到数组最后一个成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>];</span><br><span class="line"></span><br><span class="line">a.slice(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">// ['b','c']</span></span><br></pre></td></tr></table></figure>

<h2 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h2><p><code>splice</code> 方法用于删除原数组中的一部分成员，并且可以在删除的位置添加新的数组成员，返回值是被删除的元素，该方法会改变原数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start,count,addElement1,addElement2,...)</span><br></pre></td></tr></table></figure>

<p>第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数，后面的参数为要插入数组的新元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'e'</span>,<span class="string">'f'</span>) <span class="comment">// ['b','c']</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// ['a','e','f','d']</span></span><br></pre></td></tr></table></figure>

<h2 id="indexOf-、lastIndexOf"><a href="#indexOf-、lastIndexOf" class="headerlink" title="indexOf()、lastIndexOf()"></a>indexOf()、lastIndexOf()</h2><p><code>indexOf</code> 方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回 <code>-1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">a.indexOf(<span class="string">'b'</span>) <span class="comment">// 1</span></span><br><span class="line">a.indexOf(<span class="string">'x'</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p>可以接受第二个参数，表示搜索的开始位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">a.indexOf(<span class="string">'b'</span>,<span class="number">2</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><code>lastIndexOf</code> 方法返回给定元素在数组中最后一次出现的次数，如果没有出现则返回 <code>-1</code>。具体用法和 <code>indexOf</code> 相似。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p><code>map</code> 方法将数组的所有成员依次传入函数参数，然后把每一次执行结果组成一个新数组返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">a.map(<span class="function"><span class="keyword">function</span>(<span class="params">elem,index,arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elem +<span class="string">'-'</span>;</span><br><span class="line">&#125;) <span class="comment">// ['a-','b-','c-','d-']</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// ['a','b','c','d']</span></span><br></pre></td></tr></table></figure>

<p><code>map</code> 方法的回调函数有三个参数，<code>elem</code> 为当前成员的值，<code>index</code> 为当前成员的索引位置，<code>arr</code> 为原数组 <code>a</code> 。</p>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h2><p><code>forEach</code> 方法与 <code>map</code> 方法很像，也是对数组的所有成员依次执行参数函数。但是，==<code>forEach</code> 方法不返回值，只用来操作数据。如果数组遍历的目的是为了得到返回值，那么使用 <code>map</code> 方法，否则使用 <code>forEach</code> 方法。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">elem,index,arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elem+<span class="string">'-'</span>;</span><br><span class="line">&#125;) <span class="comment">// undefind(无返回值)</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// ['a','b','c','d']</span></span><br></pre></td></tr></table></figure>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><p><code>filter</code> 方法用于过滤数组成员，满足条件的成员数组组成一个新的数组返回。</p>
<p>它的参数是一个函数，所有数组依次执行该函数，返回结果为 <code>true</code> 的成员组成一个新数组返回。==该方法不改变原数组。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">a.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v&gt;<span class="number">2</span>;</span><br><span class="line">&#125;) <span class="comment">// [3, 5, 3, 4, 6]</span></span><br><span class="line"></span><br><span class="line">a <span class="comment">// [2,3,5,3,2,1,4,6]</span></span><br></pre></td></tr></table></figure>

<h2 id="in-运算符、for-…-in-循环"><a href="#in-运算符、for-…-in-循环" class="headerlink" title="in 运算符、for … in 循环"></a>in 运算符、for … in 循环</h2><p>因为数组属于特殊的对象，所以也可以使用对象的 <code>in</code> 运算符，和 <code>for ... in</code> 循环。</p>
<h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>数组的遍历可以使用 <code>for</code> 循环或者 <code>while</code> 循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; a.length ; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><p>如果一个对象的所有键名都是正数或零，并且拥有 <code>length</code> 属性，那么这个对象就很像数组，语法上成为“类似数组的对象”。</p>
<p>==典型的“类似数组对象”有函数的 <code>arguments</code> 对象，以及大多数的 <code>DOM</code> 元素集，还有字符串。==</p>
<p>==数组的 <code>slice</code> 方法可以将“类似数组的对象”转换为真正的数组。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Object-常见用法"><a href="#Object-常见用法" class="headerlink" title="Object 常见用法"></a>Object 常见用法</h1><p>==对象所有的键名都是字符串（ES6 又引入了 <code>Symbol</code> 值也可以作为键名），所以加不加引号都可以。==</p>
<p>属性的读取、操作可以使用点或者中括号运算符操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo  <span class="comment">// 1</span></span><br><span class="line">obj[foo]  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="delete-命令"><a href="#delete-命令" class="headerlink" title="delete 命令"></a>delete 命令</h2><p><code>delete</code> 命令用于删除对象的属性，删除成功后返回 <code>true</code>。==<code>delete</code>  命令只能删除对象本身的属性，无法删除继承的属性。==</p>
<h2 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h2><p><code>in</code> 运算符用于检查对象是否包含某个属性（注意，==检查的是键名而不是键值==），如果包含返回 <code>true</code>，否则返回 <code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    p:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'p'</span> <span class="keyword">in</span> obj <span class="comment">// true（自身属性）</span></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> obj <span class="comment">//ture（继承属性）</span></span><br></pre></td></tr></table></figure>

<p>==<code>in</code> 运算符有个问题，它不能识别那些属性是自身的，哪些属性是继承的。==</p>
<p>==可以使用对象的 <code>hasOwnProperty</code> 方法判断一下，是否为对象自身的属性。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'toString'</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'toString'</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="for-…-in-循环"><a href="#for-…-in-循环" class="headerlink" title="for … in 循环"></a>for … in 循环</h2><p><code>for ... in</code> 循环用来遍历一个对象的所有属性。</p>
<p>有两个点需要注意：</p>
<ul>
<li>它遍历的是对象所有可遍历的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<p>==一般情况下，都是只想遍历对象的自身属性，所以使用 <code>for ... in</code> 的时候，应该结合使用 <code>hasOwnProperty</code> 方法，在循环内部判断一下，某个属性是否为对象的自身属性。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;<span class="attr">name</span>:<span class="string">'张三'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> person)&#123;</span><br><span class="line">    <span class="keyword">if</span>(person.hasOwnProperty(key))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-keys-、Object-getOwnPropertyNames"><a href="#Object-keys-、Object-getOwnPropertyNames" class="headerlink" title="Object.keys()、Object.getOwnPropertyNames()"></a>Object.keys()、Object.getOwnPropertyNames()</h2><p>==<code>Object.keys</code> 方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">123</span>,</span><br><span class="line">  p2: <span class="number">456</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// ["p1", "p2"]</span></span><br></pre></td></tr></table></figure>

<p>==<code>Object.getOwnPropertyNames</code> 方法与 <code>Object.keys</code> 类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的（而不是继承的）所有属性名。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p1: <span class="number">123</span>,</span><br><span class="line">  p2: <span class="number">456</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj) <span class="comment">// ["p1", "p2"]</span></span><br></pre></td></tr></table></figure>

<p>一般来说，两个方法返回结果是一样的，只有涉及不可枚举属性时，才会不一样，==<code>Object.keys</code> 方法只返回可枚举的属性，<code>Object.getOwnPropertyNames</code> 方法还返回不可枚举属性名。==</p>
<h2 id="toString-应用：判断数据类型"><a href="#toString-应用：判断数据类型" class="headerlink" title="toString()应用：判断数据类型"></a>toString()应用：判断数据类型</h2><p><code>Object.prototype.toString</code> 方法返回对象的类型字符串，可以用来判断一个值的类型。</p>
<p>==由于实例对象可能会自定义 <code>toString</code> 方法，覆盖掉 <code>Object.prototype.toString</code> 方法，所以为了得到类型字符串，最好直接使用 <code>Object.prototype.toString</code> 方法。==</p>
<p>==通过函数 <code>call</code> 方法，可以在任意值上调用这个方法，来判断数据类型。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value)</span><br></pre></td></tr></table></figure>


<h2 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h2><p>==<code>Object.prototype.hasOwnProperty</code>  方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Math-用法"><a href="#Math-用法" class="headerlink" title="Math 用法"></a>Math 用法</h1><h2 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h2><p><code>Math.abs</code> 方法返回参数的绝对值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.abs(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.abs(<span class="number">-1</span>) <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-max-、Math-min"><a href="#Math-max-、Math-min" class="headerlink" title="Math.max()、Math.min()"></a>Math.max()、Math.min()</h2><p><code>Math.max</code> 方法返回参数中最大的那个值，<code>Math.min</code> 方法返回参数中最小的那个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.min(<span class="number">-2</span>,<span class="number">4</span>,<span class="number">1</span>) <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-floor-、Math-ceil"><a href="#Math-floor-、Math-ceil" class="headerlink" title="Math.floor()、Math.ceil()"></a>Math.floor()、Math.ceil()</h2><p><code>Math.floor</code> 方法返回小于参数值的最大整数（地板值）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.flor(<span class="number">3.9</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><code>Math.ceil</code> 方法返回大于单数值的最小整数（天花板值）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.ceil(<span class="number">1.1</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h2><p><code>Math.round</code> 方法用于四舍五入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(<span class="number">0.1</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.round(<span class="number">4.5</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h2><p><code>Math.random</code> 方法返回 <code>0</code> 到 <code>1</code> 之间的一个伪随机数，可能等于 <code>0</code> ，但一定小于 <code>1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.random() <span class="comment">// 0.38556088984648396</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Date-对象常见用法"><a href="#Date-对象常见用法" class="headerlink" title="Date 对象常见用法"></a>Date 对象常见用法</h1><p><code>Date</code> 对象是 JavaScript 原生的时间库。它以国际标准时间<code>（UTC）1970年1月1日00:00:00</code> 作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）。</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date()"></a>Date()</h2><p><code>Date</code> 对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>() <span class="comment">// "Sat Dec 14 2019 14:43:17 GMT+0800 (中国标准时间)"</span></span><br></pre></td></tr></table></figure>

<p><code>Date</code> 可以当作构造函数使用，使用 <code>new</code> 命令，返回一个 <code>Date</code> 对象的实例。如果不加参数，实例代表的就是当前时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="comment">// Sat Dec 14 2019 14:43:42 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>

<h2 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h2><p><code>Date.now</code> 方法返回当前时间距离时间零点（<code>1970年1月1日 00:00:00 UTC</code>）的毫秒数。时间戳的常用方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.now() <span class="comment">// 1576306248004</span></span><br></pre></td></tr></table></figure>

<h2 id="get-类方法（set-）"><a href="#get-类方法（set-）" class="headerlink" title="get 类方法（set*）"></a>get 类方法（set*）</h2><p><code>Date</code> 对象提供了一系列 <code>get*</code> 方法，用于获取某个实例对象某方面的值。</p>
<p><code>set*</code> 类方法用于设置某个实例对象某方面的值，详情翻阅相关文档，用法差不多，这里做省略。</p>
<h3 id="getTime"><a href="#getTime" class="headerlink" title="getTime()"></a>getTime()</h3><p><code>getTime</code> 返回实例对象距离 <code>1970年1月1日 00:00:00</code> 的毫秒数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳常用写法</span></span><br><span class="line">time.getTime() <span class="comment">// 1576306856840</span></span><br></pre></td></tr></table></figure>

<h3 id="getFullYear-、getMonth-、getDate-、getDay"><a href="#getFullYear-、getMonth-、getDate-、getDay" class="headerlink" title="getFullYear()、getMonth()、getDate()、getDay()"></a>getFullYear()、getMonth()、getDate()、getDay()</h3><p><code>getFullYear</code> 返回四位数的年份。</p>
<p><code>getMonth</code> 返回月份（0 表示1月，11 表示 12月）。</p>
<p><code>getDate</code> 方法返回实例对象对应的每个月的几号（从 1 开始）。</p>
<p><code>getDay</code> 方法返回星期几，星期日为 0 ，星期一为 1 ，以此类推。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line">time.getFullYear() <span class="comment">// 2019</span></span><br><span class="line">time.getMonth() <span class="comment">// 11</span></span><br><span class="line">time.getDate() <span class="comment">// 14</span></span><br><span class="line">time.getDay() <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h3 id="getHours-、getMinutes-、getSeconds"><a href="#getHours-、getMinutes-、getSeconds" class="headerlink" title="getHours()、getMinutes()、getSeconds()"></a>getHours()、getMinutes()、getSeconds()</h3><p><code>getHours</code> 返回小时（0 - 23）</p>
<p><code>getMinutes</code> 返回分钟</p>
<p><code>getSeconds</code> 返回秒</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line">time.getHours() <span class="comment">// 15</span></span><br><span class="line">time.getMinutes() <span class="comment">// 17</span></span><br><span class="line">time.getSeconds() <span class="comment">// 45</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Regexp-用法"><a href="#Regexp-用法" class="headerlink" title="Regexp 用法"></a>Regexp 用法</h1><p>暂省略</p>
<hr>
<h1 id="JSON-对象用法"><a href="#JSON-对象用法" class="headerlink" title="JSON 对象用法"></a>JSON 对象用法</h1><p><code>JSON</code> 格式是一种用于数据交换的文本格式。</p>
<p>每个 <code>JSON</code> 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。</p>
<p><code>JSON</code> 对值的类型和格式有严格的规定：</p>
<ul>
<li>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</li>
<li>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和 <code>null</code>（不能使用 <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code> 和 <code>undefined</code>）。</li>
<li>==字符串必须使用双引号表示，不能使用单引号。==</li>
<li>对象的键名必须放在双引号里面。</li>
<li>数组或对象最后一个成员的后面，不能加逗号。</li>
</ul>
<h2 id="JSON-stringify-、JSON-parse"><a href="#JSON-stringify-、JSON-parse" class="headerlink" title="JSON.stringify()、JSON.parse()"></a>JSON.stringify()、JSON.parse()</h2><p><code>JSON.stringify</code> 方法用于将一个值转为 <code>JSON</code> 字符串。该字符串符合 <code>JSON</code> 格式，并且可以被 <code>JSON.parse</code> 方法还原。</p>
<p><code>JSON.parse</code> 方法用于将 <code>JSON</code> 字符串转换成对应的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;<span class="attr">a</span>:<span class="number">123</span>,<span class="attr">b</span>:<span class="string">'BBB'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj) <span class="comment">// "&#123;"a":123,"b":"BBB"&#125;"</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>JavaScript 语言使用构造函数（<code>constructor</code>）作为对象的模板。所谓“构造函数”，就是专门用来生成实例对象的函数。</p>
<p>构造函数就是一个普通的函数，为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造函数特点：</p>
<ul>
<li>函数体内部使用了 <code>this</code> 关键字，代表了所要生成对象的实例。</li>
<li>生成对象时，必须使用 <code>new</code> 命令。</li>
</ul>
<h2 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h2><p><code>new</code> 命令的作用，就是执行构造函数，返回一个实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle();</span><br><span class="line">v.price <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>

<p><code>new</code> 命令原理：</p>
<ul>
<li>==创建一个空对象，作为要返回的对象实例。==</li>
<li>==将这个空对象的原型，指向构造函数的 <code>prototype</code> 属性。==</li>
<li>==将这个空对象赋值给函数内部的 <code>this</code> 关键字。==</li>
<li>==开始执行构造函数内部代码。==</li>
</ul>
<h2 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h2><p>构造函数作为模板，可以生成实例对象。但是，有时候需要用对象作为模板，生成新的实例对象，这时就可以使用 <code>Object.create()</code> 方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> guopengsong = &#123;</span><br><span class="line">    mingzi:<span class="string">'郭鹏松'</span>,</span><br><span class="line">    xingbie:<span class="string">'男'</span>,</span><br><span class="line">    leixing:<span class="string">'人类'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pingyuan = <span class="built_in">Object</span>.create(guopengsong)</span><br><span class="line"></span><br><span class="line">pingyuan.leixing <span class="comment">// 人类</span></span><br><span class="line">pingyuan.xingbie <span class="comment">// 男</span></span><br></pre></td></tr></table></figure>

<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p><code>this</code> 就是属性或方法“当前”所在的对象。不管是什么场合，<code>this</code> 都有一个共同点：==它总是返回一个对象。==</p>
<p>==在 JavaScript 语言中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code> 就是函数运行时所在的对象（环境）。== 这本来不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，<code>this</code> 的指向时动态的，没办法事先确定到底指向哪个对象，这才是让人困惑的地方。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'姓名：'</span>+ <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">  name: <span class="string">'李四'</span>,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.describe() <span class="comment">// "姓名：张三"</span></span><br><span class="line">B.describe() <span class="comment">// "姓名：李四"</span></span><br></pre></td></tr></table></figure>

<p><code>this</code> 使用场合：</p>
<ul>
<li>==全局环境：全局环境使用 <code>this</code> ，它指向的就是顶层对象 <code>window</code>。==</li>
<li>==构造函数：构造函数中的 <code>this</code> ，指的就是实例对象。==</li>
<li>==对象的方法：如果对象的方法里面包含 <code>this</code> , <code>this</code> 的指向就是方法所运行时所在的对象。该方法赋值给另一个对象，就会改变 this 的指向。==</li>
</ul>
<p><code>this</code> 使用注意点：</p>
<ul>
<li>避免多层 <code>this</code>：由于 <code>this</code> 的指向是不确定的，避免在函数中包含多层 <code>this</code>。</li>
<li>避免数组方法中 <code>this</code>：数组的 <code>map</code> 和 <code>foreach</code> 方法，允许提供一个函数作为参数。这个函数内部不应该使用 <code>this</code>。</li>
<li>避免回调函数中的 <code>this</code>：回调函数中的 <code>this</code> 往往会改变指向，最好避免使用。</li>
</ul>
<h3 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h3><p>==JavaScript 提供了 <code>call、apply、bind</code> 这三个方法，来切换/固定 <code>this</code> 的指向。==</p>
<h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><p>==函数实例的 <code>call</code> 方法，可以指定函数内部的 <code>this</code>  指向（即函数执行时所在的作用域），然后在指定的作用域中，调用该函数。==</p>
<p><code>call</code> 方法的参数，应该是一个对象。如果参数为 <code>空、null</code> 和 <code>undefined</code> ，则默认传入全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line">f.call(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>==<code>call</code> 方法还可以接受多个参数。<code>call</code> 的第一个参数就是 <code>this</code> 所要指向的那个对象，后面的参数则是函数调用时所需的参数。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisValue, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(<span class="keyword">this</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h4><p><code>apply</code> 方法的作用与 <code>call</code> 方法类似，也是改变 <code>this</code> 指向，然后再调用该函数。==唯一的区别就是，它接收一个数组作为函数执行时的参数。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisValue, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure>

<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h4><p><code>bind</code> 方法用于将函数体内的 <code>this</code> 绑定到某个对象，然后返回一个新函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime() <span class="comment">// 1481869925657</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> print = d.getTime;</span><br><span class="line">print() <span class="comment">// Uncaught TypeError: this is not a Date object.</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，我们将 <code>d.getTime()</code> 方法赋给变量 <code>print</code>，然后调用 <code>print()</code> 就报错了。这是因为 <code>getTime()</code> 方法内部的 <code>this</code>，绑定 <code>Date</code> 对象的实例，赋给变量 <code>print</code> 以后，内部的 <code>this</code> 已经不指向 <code>Date</code> 对象的实例了。</p>
<p><code>bind()</code> 方法可以解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = d.getTime.bind(d);</span><br><span class="line">print() <span class="comment">// 1481869925657</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind()</code> 方法将 <code>getTime()</code> 方法内部的 <code>this</code> 绑定到 <code>d</code> 对象，这时就可以安全地将这个方法赋值给其他变量了。</p>
<p>==<code>bind()</code> 的作用与 <code>call()</code> 和 <code>apply()</code> 一样，都是可以改变函数运行时上下文，区别是 <code>call()</code> 和 <code>apply()</code> 在调用函数之后会立即执行，而 <code>bind()</code> 方法调用并改变函数运行时上下文后，返回一个新的函数，供我们需要时再调用。==</p>
<h3 id="如何选用"><a href="#如何选用" class="headerlink" title="如何选用"></a>如何选用</h3><ul>
<li>如果不需要关心具体有多少参数被传入函数，选用 <code>apply()</code>；</li>
<li>如果确定函数可接收多少个参数，并且想一目了然表达形参和实参的对应关系，用 <code>call()</code>；</li>
<li>如果我们想要将来再调用方法，不需立即得到函数返回结果，则使用 <code>bind()</code>。</li>
</ul>
<h3 id="特点总结"><a href="#特点总结" class="headerlink" title="特点总结"></a>特点总结</h3><ul>
<li><code>call()</code>、<code>apply()</code> 和 <code>bind()</code> 都是用来改变函数执行时的上下文，可借助它们实现继承；</li>
<li><code>call()</code> 和 <code>apply()</code> 唯一区别是参数不一样，<code>call()</code> 是 <code>apply()</code> 的语法糖；</li>
<li><code>bind()</code> 是返回一个新函数，供以后调用，而 <code>apply()</code> 和 <code>call()</code> 是立即调用。</li>
</ul>
<h2 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h2><p>通过构造函数为实例对象定义属性，虽然方便，但是又个缺点，==同一个构造函数的多个实例对象之间，无法共享属性，从而对系统资源造成浪费。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name,color</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">    <span class="keyword">this</span>.meow = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'喵喵'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">'大毛'</span>,<span class="string">'白色'</span>)；</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Cat(<span class="string">'二毛'</span>,<span class="string">'黄色'</span>);</span><br><span class="line"></span><br><span class="line">cat1.meow === cat2.meow <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h2><p>JavaScript 继承机制的设计思想：==原型对象的所有属性和方法，都能被实例对象共享。如果属性和方法定义在原型上，那么所有实例就能共享。==</p>
<p>==JavaScript 规定，每个函数都有一个 <code>prototype</code> 属性，指向一个对象。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">typeof</span> f.prototype <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure>

<p>对于普通函数来说，该属性基本无用。==对于构造函数来说，生成实例的时候，该属性（<code>prototype</code>）会自动成为实例对象的原型。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.color = <span class="string">'white'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Animal(<span class="string">'大毛'</span>);</span><br><span class="line"><span class="keyword">var</span> cat2 = <span class="keyword">new</span> Animal(<span class="string">'二毛'</span>);</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// 'white'</span></span><br><span class="line">cat2.color <span class="comment">// 'white'</span></span><br></pre></td></tr></table></figure>

<p>==原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就会立刻体现在所有实例对象上。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.color = <span class="string">'yellow'</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// "yellow"</span></span><br><span class="line">cat2.color <span class="comment">// "yellow"</span></span><br></pre></td></tr></table></figure>

<p>==如果实例对象自身就有某个属性或者方法，它就不会再去原型对象寻找这个属性或者方法。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat1.color = <span class="string">'black'</span>;</span><br><span class="line"></span><br><span class="line">cat1.color <span class="comment">// 'black'</span></span><br><span class="line">cat2.color <span class="comment">// 'yellow'</span></span><br><span class="line">Animal.prototype.color <span class="comment">// 'yellow';</span></span><br></pre></td></tr></table></figure>

<p>==原型对象的作用，就是定义所有实例对象共享的属性和方法。==</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>==JavaScript 规定，所有的对象都有自己的原型对象（<code>prototype</code>）。一方面，任何一个对象，都可以充当其它对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”：对象到原型，再到原型的原型……==</p>
<p>==一层一层往上追溯，所有的对象原型最终都可以追溯到 <code>Object.prototype</code> ，即 <code>Object</code> 构造函数的 <code>prototype</code> 属性。<code>Object.prototype</code> 的原型是 <code>null</code>。<code>null</code> 没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是 <code>null</code>。==</p>
<h2 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h2><p>==<code>prototype</code> 对象有一个 <code>constructor</code> 属性，默认指向 <code>prototype</code> 对象所在的构造函数。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line">P.prototype.constructor === P <span class="comment">// ture</span></span><br></pre></td></tr></table></figure>

<p>==<code>constructor</code> 属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改 <code>constructor</code> 属性，防止引用的时候出错。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 坏的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">    method1:<span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line">C.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>:C,</span><br><span class="line">    method1:function(...)&#123;...&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的写法</span></span><br><span class="line">C.prototype.method1 = <span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>确定 <code>constructor</code> 属性是什么函数，可以使用 <code>name</code> 属性，从实例得到构造函数的名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo()</span><br><span class="line"></span><br><span class="line">f.constructor.name <span class="comment">// "Foo"</span></span><br></pre></td></tr></table></figure>

<h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>==<code>instanceof</code> 运算符返回一个布尔值，表示对象是否是某个构造函数的实例。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">p <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>==由于 <code>instanceof</code> 检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回 <code>true</code>。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>==<code>instanceof</code> 运算符只能适用于对象，不适用于原始类型的值。==</p>
<h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。==第一步是在子类的构造函数中，调用父类的构造函数。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Super.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.prop = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub</code> 是子类的构造函数，<code>this</code> 是子类的实例。在实例上调用父类的构造函数 <code>Super</code>，就会让子类实例具有父类实例的属性。</p>
<p>==第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.method = <span class="string">'...'</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub.prototype</code>  是子类的原型，要将它赋值为 <code>Object.create(Super.prototype)</code> ，而不是直接等于 <code>Super.prototype</code>。否则后面两行对 <code>Sub.prototype</code> 的操作，会连父类的原型 <code>Super.prototype</code> 一起修改掉。</p>
<p>举例来说，下面是一个 Shape 构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x += x;</span><br><span class="line">  <span class="keyword">this</span>.y += y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要让 Rectangle 构造函数继承 Shape。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步，子类继承父类的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.base = Shape;</span><br><span class="line">  <span class="keyword">this</span>.base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二步，子类继承父类的原型</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br></pre></td></tr></table></figure>

<p>采用这样的写法以后，<code>instanceof</code> 运算符会对子类和父类的构造函数，都返回 <code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line">rect <span class="keyword">instanceof</span> Rectangle  <span class="comment">// true</span></span><br><span class="line">rect <span class="keyword">instanceof</span> Shape  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassB.prototype.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ClassA.prototype.print.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类B的 <code>print</code> 方法先调用父类A的 <code>print</code> 方法，再部署自己的代码。这就等于继承了父类A的 <code>print</code> 方法。</p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hello = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">M2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.world = <span class="string">'world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  M1.call(<span class="keyword">this</span>);</span><br><span class="line">  M2.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 M1</span></span><br><span class="line">S.prototype = <span class="built_in">Object</span>.create(M1.prototype);</span><br><span class="line"><span class="comment">// 继承链上加入 M2</span></span><br><span class="line"><span class="built_in">Object</span>.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定构造函数</span></span><br><span class="line">S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> S();</span><br><span class="line">s.hello <span class="comment">// 'hello'</span></span><br><span class="line">s.world <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，子类S同时继承了父类 M1 和 M2 。这种模式又称为 <code>Mixin</code>（混入）。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>暂时省略</p>
<h2 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a>Object 对象的相关方法</h2><p>关于面向对象编程，<code>Object</code> 对象也提供了相关的方法。</p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>==<code>Object.getPrototypeOf</code> 方法返回参数对象的原型。这是获取原型对象的标准方法。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(f) === F.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p>==<code>Object.setPrototypeOf</code> 方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(a,b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(a) === b <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a.x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p><code>Object.create</code> 方法可以实现从一个实例对象，生成另一个实例对象。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。==该实例对象完全继承原型对象的属性。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    print:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例对象</span></span><br><span class="line"><span class="keyword">var</span> B = <span class="built_in">Object</span>.create(A)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(B) === A <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">B.print() <span class="comment">// hello</span></span><br><span class="line">B.print === A.print <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>下面三种方式生成的新对象是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>==如果想要生成一个不继承任何属性（比如没有 <code>toString</code> 和 <code>valueOf</code> 方法）的对象，可以将 <code>Object.create</code> 的参数设为 <code>null</code> 。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">obj.valueOf() <span class="comment">// TypeError: Object [object Object] has no method 'valueOf'</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf"></a>Object.prototype.isPrototypeOf</h3><p>实例对象的 <code>isPrototypeOf</code> 方法，用来判断该对象是否为参数对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(o1);</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(o2);</span><br><span class="line"></span><br><span class="line">o2.isPrototypeOf(o3) <span class="comment">// true</span></span><br><span class="line">o1.isPrototypeOf(o2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.__proto__"></a><code>Object.prototype.__proto__</code></h3><p>实例对象的属性（前后两个下划线）<code>__proto__</code> ，返回该对象的原型，该属性可读写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = p</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="获取原型对象方法比较"><a href="#获取原型对象方法比较" class="headerlink" title="获取原型对象方法比较"></a>获取原型对象方法比较</h3><p>获取实例对象 <code>obj</code> 的原型对象，有三种方法：</p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>==三种方法中，<code>__proto__</code> 只有浏览器才需要部署，其它环境可以不部署。而 <code>obj.constructor.prototype</code> 在手动改变原型对象时，有可能失效。推荐使用第三种 <code>Object.getPrototypeOf</code> 方法，获取原型对象。==</p>
<h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>拷贝一个对象，需要做到下面两点：</p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性</li>
</ul>
<hr>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h2><p><code>setTimeout</code> 函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p>
<p><code>setTimeout</code> 函数接受两个参数，第一个参数 <code>func|code</code> 是将要推迟执行的函数名或者一段代码，第二个参数 <code>delay</code> 是推迟执行的毫秒数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = setTimeout(func|code,delay);</span><br></pre></td></tr></table></figure>

<h2 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h2><p><code>setInterval</code> 函数的用法与 <code>setTimeout</code> 完全一致，区别仅在于 <code>setInterval</code> 指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="clearTimeout-、clearInterval"><a href="#clearTimeout-、clearInterval" class="headerlink" title="clearTimeout()、clearInterval()"></a>clearTimeout()、clearInterval()</h2><p><code>setTimeout</code> 和 <code>setInterval</code> 函数，都返回一个整数值，表示计数器编号。将该整数编号传入 <code>clearTimeout</code> 和 <code>clearInterval</code> 函数，就可以取消对应的定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id1 = setTimeout(f,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> id2 = setInterval(f,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">clearTimeout(id1);</span><br><span class="line">clearInterval(id2);</span><br></pre></td></tr></table></figure>

<h1 id="DOM-概述"><a href="#DOM-概述" class="headerlink" title="DOM 概述"></a>DOM 概述</h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>==DOM 是 JavaScript 是操作网页的接口，全称为“文档对象模型”。== 它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。严格讲，DOM 不是 JavaScript 语法的一部分，但是 DOM 操作是 JavaScript 常见任务，离开了 DOM ，JavaScript 就无法控制网页。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>==DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。==</p>
<p>节点类型有 7 种：</p>
<ol>
<li>Document：整个文档树的顶层节点</li>
<li>DocumentType：doctype 标签（比如 <code>&lt;!DOCTYPE html&gt;</code>）</li>
<li>Element：网页的各种 HTML 标签（比如 <code>&lt;body&gt;、&lt;a&gt;</code> 等）</li>
<li>Attr：网页元素的属性（比如 <code>class=&quot;right&quot;</code>）</li>
<li>Text：标签之间或标签包含的文本</li>
<li>Comment：注释</li>
<li>DocumentFragment：文档的片段</li>
</ol>
<p>浏览器提供一个原生的节点对象 Node，上面这 7 种节点都继承了 Node，因此有一些共同属性和方法。</p>
<h2 id="节点树"><a href="#节点树" class="headerlink" title="节点树"></a>节点树</h2><p>==一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。== 它有一个顶层节点，下一层都是顶层节点的子节点，然后子节点又有自己的子节点，就这样层层衍生出一个金字塔结构，又像一棵树。</p>
<p>除了根节点(HTML 网页的顶层容器标签<code>&lt;html&gt;</code>)，其它节点都有三种层级关系：</p>
<ul>
<li>父节点关系（parentNode）：直接的那个上级节点</li>
<li>子节点关系（childNodes）：直接的下级节点</li>
<li>同级节点关系（sibling）：拥有同一个父节点的节点</li>
</ul>
<h1 id="Node-接口"><a href="#Node-接口" class="headerlink" title="Node 接口"></a>Node 接口</h1><p>所有 DOM 节点对象都继承了 Node 接口，拥有一些共同的属性和方法。这是 DOM 操作的基础。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="Node-prototype-nodeType"><a href="#Node-prototype-nodeType" class="headerlink" title="Node.prototype.nodeType"></a>Node.prototype.nodeType</h3><p><code>nodeType</code> 属性返回一个整数值，表示节点类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>

<p>Node 对象定义了几个常量，对应这些类型值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.nodeType === Node.DOCUMENT_NODE <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>不同节点的 nodeType 属性值：</p>
<ul>
<li>文档节点（document）：9，对应常量Node.DOCUMENT_NODE</li>
<li>==元素节点（element）：1，对应常量Node.ELEMENT_NODE==</li>
<li>==属性节点（attr）：2，对应常量Node.ATTRIBUTE_NODE==</li>
<li>==文本节点（text）：3，对应常量Node.TEXT_NODE==</li>
<li>文档片断节点（DocumentFragment）：11，对应常量Node.DOCUMENT_FRAGMENT_NODE</li>
<li>文档类型节点（DocumentType）：10，对应常量Node.DOCUMENT_TYPE_NODE</li>
<li>注释节点（Comment）：8，对应常量Node.COMMENT_NODE</li>
</ul>
<p>==常用的节点为元素节点、属性节点、文本节点，== 其它了解即可，需要时请查阅相关文档。</p>
<h3 id="Node-prototype-nodeName"><a href="#Node-prototype-nodeName" class="headerlink" title="Node.prototype.nodeName"></a>Node.prototype.nodeName</h3><p><code>nodeName</code> 属性返回节点的名称。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'d1'</span>);</span><br><span class="line">div.nodeName <span class="comment">// "DIV"</span></span><br></pre></td></tr></table></figure>

<p>不同节点的 nodeName 属性值如下：</p>
<ul>
<li>文档节点（document）：#document</li>
<li>==元素节点（element）：大写的标签名==</li>
<li>==属性节点（attr）：属性的名称==</li>
<li>文本节点（text）：#text</li>
<li>文档片断节点（DocumentFragment）：#document-fragment</li>
<li>文档类型节点（DocumentType）：文档的类型</li>
<li>注释节点（Comment）：#comment</li>
</ul>
<h3 id="Node-prototype-nodeValue"><a href="#Node-prototype-nodeValue" class="headerlink" title="Node.prototype.nodeValue"></a>Node.prototype.nodeValue</h3><p>nodeValue 属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。</p>
<p>==只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点 nodeValue 可以返回结果，其它节点一律返回 null 。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="d1"&gt;hello world&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'d1'</span>);</span><br><span class="line">div.nodeValue <span class="comment">// null</span></span><br><span class="line">div.firstChild.nodeValue <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>

<h2 id="Node-prototype-textContent"><a href="#Node-prototype-textContent" class="headerlink" title="Node.prototype.textContent"></a>Node.prototype.textContent</h2><p><code>textContent</code> 属性返回当前节点和它的后代节点的文本内容。该属性可读写，设置该属性的值，会用一个新的文本节点，替换所有原来的子节点。它可以自动对 HTML 标签转义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id="divA"&gt;This is &lt;span&gt;some&lt;/span&gt; text&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'divA'</span>).textContent;</span><br><span class="line"><span class="comment">//This is some text</span></span><br></pre></td></tr></table></figure>

<p>==<code>textContent</code> 属性自动忽略当前节点内部的 HTML 标签，返回所有文本内容。==</p>
<h3 id="Node-prototype-baseURI"><a href="#Node-prototype-baseURI" class="headerlink" title="Node.prototype.baseURI"></a>Node.prototype.baseURI</h3><p><code>baseURI</code> 属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 <code>URL</code>。该属性为只读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前网页的网址为</span></span><br><span class="line"><span class="comment">// http://www.example.com/index.html</span></span><br><span class="line"><span class="built_in">document</span>.baseURI</span><br><span class="line"><span class="comment">// "http://www.example.com/index.html"</span></span><br></pre></td></tr></table></figure>

<h3 id="Node-prototype-nextSibling"><a href="#Node-prototype-nextSibling" class="headerlink" title="Node.prototype.nextSibling"></a>Node.prototype.nextSibling</h3><p><code>Node.nextSibling</code> 属性返回紧跟在==当前节点后面的第一个同级节点==。如果当前节点后面没有同级节点，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="d1"&gt;hello&lt;/div&gt;&lt;div id="d2"&gt;world&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d1 = <span class="built_in">document</span>.getElementById(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">var</span> d2 = <span class="built_in">document</span>.getElementById(<span class="string">'d2'</span>);</span><br><span class="line"></span><br><span class="line">d1.nextSibling === d2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>注意，该属性还包括文本节点和注释节点。因此如果当前节点后面有空格，该属性会返回一个文本节点，内容为空格。</p>
<h3 id="Node-prototype-previousSibling"><a href="#Node-prototype-previousSibling" class="headerlink" title="Node.prototype.previousSibling"></a>Node.prototype.previousSibling</h3><p><code>previousSibling</code> 属性返回==当前节点前面的、距离最近的同级节点==。如果当前节点前面没有同级节点，则返回 null 。用法和 nextSibling 完全一样。</p>
<h3 id="Node-prototype-parentNode"><a href="#Node-prototype-parentNode" class="headerlink" title="Node.prototype.parentNode"></a>Node.prototype.parentNode</h3><p><code>parentNode</code> 属性返回当前节点的父节点。==对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.parentNode) &#123;</span><br><span class="line">  node.parentNode.removeChild(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过 <code>node.parentNode</code> 属性将 <code>node</code> 节点从文档里面移除。</p>
<h3 id="Node-prototype-parentElement"><a href="#Node-prototype-parentElement" class="headerlink" title="Node.prototype.parentElement"></a>Node.prototype.parentElement</h3><p><code>parentElement</code> 属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.parentElement) &#123;</span><br><span class="line">  node.parentElement.style.color = <span class="string">'red'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，父元素节点的样式设定了红色。</p>
<p>由于==父节点只可能是三种类型：元素节点、文档节点（document）和文档片段节点（documentfragment）。== <code>parentElement</code> 属性相当于把后两种父节点都排除了。</p>
<h3 id="Node-prototype-firstChild、Node-prototype-lastChild"><a href="#Node-prototype-firstChild、Node-prototype-lastChild" class="headerlink" title="Node.prototype.firstChild、Node.prototype.lastChild"></a>Node.prototype.firstChild、Node.prototype.lastChild</h3><p><code>firstChild</code> 属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回 <code>null</code>。<br><code>lastChild</code> 属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回 <code>null</code>，用法与 <code>firstChild</code> 属性相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id="p1"&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>);</span><br><span class="line">p1.firstChild.nodeName <span class="comment">// "SPAN"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code> 元素的第一个子节点是 <code>span</code> 元素。</p>
<p>注意，<code>firstChild</code> 返回的==除了元素节点，还可能是文本节点或者注释节点。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;p id="p1"&gt;</span></span><br><span class="line"><span class="comment">//   &lt;span&gt;First span&lt;/span&gt;</span></span><br><span class="line"><span class="comment">//  &lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>);</span><br><span class="line">p1.firstChild.nodeName <span class="comment">// "#text"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code> 元素与 <code>span</code> 元素之间有空白字符，这导致 <code>firstChild</code> 返回的是文本节点。</p>
<h3 id="Node-prototype-childNodes"><a href="#Node-prototype-childNodes" class="headerlink" title="Node.prototype.childNodes"></a>Node.prototype.childNodes</h3><p><code>childNodes</code> 属性返回一个类似数组的对象（<code>NodeList</code> 集合），成员包括==当前节点的所有子节点==。注意，==除了元素节点，<code>childNodes</code>  属性返回值还包括文本节点和注释节点。==</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Node-prototype-appendChild"><a href="#Node-prototype-appendChild" class="headerlink" title="Node.prototype.appendChild()"></a>Node.prototype.appendChild()</h3><p><code>appendChild()</code> 方法==接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。== 该方法的返回值就是插入文档的子节点。如果参数节点是 DOM 已经存在的节点，<code>appendChild()</code> 方法会将其从原来的位置，移动到新位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(p);</span><br></pre></td></tr></table></figure>

<h3 id="Node-prototype-hasChildNodes"><a href="#Node-prototype-hasChildNodes" class="headerlink" title="Node.prototype.hasChildNodes()"></a>Node.prototype.hasChildNodes()</h3><p><code>hasChildNodes</code> 方法返回一个布尔值，表示当前节点是否有子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (foo.hasChildNodes()) &#123;</span><br><span class="line">  foo.removeChild(foo.childNodes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，如果 <code>foo</code> 节点有子节点，就移除第一个子节点。</p>
<p>注意，==子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，<code>hasChildNodes</code> 方法也会返回 <code>true</code>。==</p>
<p>判断一个节点有没有子节点，有许多种方法，下面是其中的三种。</p>
<ol>
<li><code>node.hasChildNodes()</code></li>
<li><code>node.firstChild !== null</code></li>
<li><code>node.childNodes &amp;&amp; node.childNodes.length &gt; 0</code></li>
</ol>
<h3 id="Node-prototype-cloneNode"><a href="#Node-prototype-cloneNode" class="headerlink" title="Node.prototype.cloneNode()"></a>Node.prototype.cloneNode()</h3><p><code>cloneNode</code> 方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。返回值是一个克隆出来的新的节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneUl = <span class="built_in">document</span>.querySelect(<span class="string">'ul'</span>).cloneNode(ture);</span><br></pre></td></tr></table></figure>

<p>使用注意点：</p>
<ul>
<li>克隆一个节点，会拷贝节点所有属性，但是会丧失 <code>addEventLister</code> 方法和 <code>on-</code> 属性等事件。</li>
<li>该方法返回的节点不在文档之中，即没有任何父节点，必须使用诸如 <code>Node.appendChild</code> 这样的方法添加到文档中。</li>
<li>克隆一个节点后，DOM 有可能会出现两个相同 <code>id</code> 属性或其他相同属性的网页元素，需要手动修改。</li>
</ul>
<h3 id="Node-prototype-insertBefore"><a href="#Node-prototype-insertBefore" class="headerlink" title="Node.prototype.insertBefore()"></a>Node.prototype.insertBefore()</h3><p><code>insertBefore</code> 方法用于将某个节点插入父节点内部的指定位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> insertedNode = parentNode.insertBefore(newNode,referenceNode);</span><br></pre></td></tr></table></figure>

<p>第一个参数是要插入的节点 <code>newNode</code>，第二个参数是父节点 <code>parentNode</code> 内部的一个子节点 <code>referenceNode</code>。<code>newNode</code> 将插在 <code>referenceNode</code> 这个子节点的前面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(p, <span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure>

<p>上面代码中，新建一个 <code>&lt;p&gt;</code> 节点，插在 <code>document.body.firstChild</code> 的前面，也就是成为 <code>document.body</code> 的第一个子节点。</p>
<p>由于==不存在 <code>insertAfter</code> 方法==，如果新节点要插在父节点的某个子节点后面，可以用 <code>insertBefore</code> 方法结合 <code>nextSibling</code> 属性模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.insertBefore(s1, s2.nextSibling);</span><br></pre></td></tr></table></figure>

<h3 id="Node-prototype-removeChild"><a href="#Node-prototype-removeChild" class="headerlink" title="Node.prototype.removeChild()"></a>Node.prototype.removeChild()</h3><p><code>removeChild</code> 方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divA = <span class="built_in">document</span>.getElementById(<span class="string">'A'</span>);</span><br><span class="line">divA.parentNode.removeChild(divA);</span><br></pre></td></tr></table></figure>

<p>上面代码移除了 <code>divA</code> 节点。注意，==该方法是在 <code>divA</code> 的父节点上调用的，不是在 <code>divA</code> 上调用的。==</p>
<p>下面是如何移除当前节点的所有子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'top'</span>);</span><br><span class="line"><span class="keyword">while</span> (element.firstChild) &#123;</span><br><span class="line">  element.removeChild(element.firstChild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Node-prototype-replaceChild"><a href="#Node-prototype-replaceChild" class="headerlink" title="Node.prototype.replaceChild()"></a>Node.prototype.replaceChild()</h3><p><code>replaceChild</code> 方法用于将一个新的节点，替换当前节点的某一个子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> replacedNode = parentNode.replaceChild(newChild, oldChild);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>replaceChild</code> 方法接受两个参数，第一个参数 <code>newChild</code> 是用来替换的新节点，第二个参数 <code>oldChild</code> 是将要替换走的子节点。返回值是替换走的那个节点 <code>oldChild</code>。</p>
<h1 id="NodeList接口、HTMLCollection-接口"><a href="#NodeList接口、HTMLCollection-接口" class="headerlink" title="NodeList接口、HTMLCollection 接口"></a>NodeList接口、HTMLCollection 接口</h1><p>DOM 提供两种节点集合，用于容纳多个节点：<code>NodeList</code> 和 <code>HTMLCollection</code>。主要区别是，<code>NodeList</code> 可以包含各种类型的节点，<code>HTMLCollection</code> 只能包含 HTML 元素节点。</p>
<h2 id="NodeList接口"><a href="#NodeList接口" class="headerlink" title="NodeList接口"></a>NodeList接口</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>NodeList</code> 实例是一个类似数组的对象，它的成员是节点对象。</p>
<p>如下方法可以得到 NodeList 实例：</p>
<ul>
<li><code>Node.childNodes</code></li>
<li><code>document.querySelectorAll()</code> 等节点搜索</li>
</ul>
<p>==<code>NodeList</code> 实例很像数组，可以使用 <code>length</code> 属性和 <code>forEach</code> 方法。但是，它不是数组，不能使用 <code>pop</code> 或 <code>push</code> 之类数组特有的方法。==</p>
<h3 id="NodeList-prototype-length"><a href="#NodeList-prototype-length" class="headerlink" title="NodeList.prototype.length"></a>NodeList.prototype.length</h3><p><code>length</code> 属性返回 <code>NodeList</code> 实例包含的节点数量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">'xxx'</span>).length   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h3 id="NodeList-prototype-forEach"><a href="#NodeList-prototype-forEach" class="headerlink" title="NodeList.prototype.forEach()"></a>NodeList.prototype.forEach()</h3><p><code>forEach</code> 方法用于遍历 <code>NodeList</code> 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的 <code>forEach</code> 方法完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> children = <span class="built_in">document</span>.body.childNodes;</span><br><span class="line">children.forEach(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">item, i, list</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<h3 id="NodeList-prototype-item"><a href="#NodeList-prototype-item" class="headerlink" title="NodeList.prototype.item()"></a>NodeList.prototype.item()</h3><p><code>item</code> 方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childNodes.item(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>item(0)</code> 返回第一个成员。</p>
<p>所有类似数组的对象，都可以使用方括号运算符取出成员。==一般情况下，都是使用方括号运算符，而不使用 <code>item</code> 方法。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.childNodes[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries"><a href="#NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries" class="headerlink" title="NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()"></a>NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</h3><p>这三个方法都返回一个 ES6 的遍历器对象，可以通过 <code>for...of</code> 循环遍历获取每一个成员的信息。区别在于，<code>keys()</code> 返回键名的遍历器，<code>values()</code> 返回键值的遍历器，<code>entries()</code> 返回的遍历器同时包含键名和键值的信息。</p>
<h2 id="HTMLCollection-接口"><a href="#HTMLCollection-接口" class="headerlink" title="HTMLCollection 接口"></a>HTMLCollection 接口</h2><p>HTMLCollection 是一个节点对象的集合，只能包含元素节点（<code>element</code>），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与 NodeList 接口不同，HTMLCollection 没有 <code>forEach</code> 方法，只能使用 <code>for</code> 循环遍历。</p>
<p>返回 HTMLCollection 实例的，主要是一些 Document 对象的集合属性，比如 <code>document.links、document.forms、document.images</code> 等。</p>
<h1 id="ParentNode-接口、ChildNode-接口"><a href="#ParentNode-接口、ChildNode-接口" class="headerlink" title="ParentNode 接口、ChildNode 接口"></a>ParentNode 接口、ChildNode 接口</h1><p>节点对象除了继承 Node 接口以外，还拥有其他接口。<code>ParentNode</code> 接口表示当前节点是一个父节点，提供一些处理子节点的方法。<code>ChildNode</code> 接口表示当前节点是一个子节点，提供一些相关方法。</p>
<h2 id="ParentNode-接口"><a href="#ParentNode-接口" class="headerlink" title="ParentNode 接口"></a>ParentNode 接口</h2><p>只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，==只有这三类节点会拥有 ParentNode 接口。==</p>
<h3 id="ParentNode-children"><a href="#ParentNode-children" class="headerlink" title="ParentNode.children"></a>ParentNode.children</h3><p><code>children</code> 属性返回一个 <code>HTMLCollection</code> 实例，成员是当前节点的所有元素子节点，该属性只读。</p>
<p>下面是遍历某个节点的所有元素子节点的示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; el.children.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，==<code>children</code> 属性只包括元素子节点，不包括其他类型的子节点（比如文本子节点）。== 如果没有元素类型的子节点，返回值 HTMLCollection 实例的 <code>length</code> 属性为 <code>0</code>。</p>
<h3 id="ParentNode-firstElementChild、ParentNode-lastElementChild"><a href="#ParentNode-firstElementChild、ParentNode-lastElementChild" class="headerlink" title="ParentNode.firstElementChild、ParentNode.lastElementChild"></a>ParentNode.firstElementChild、ParentNode.lastElementChild</h3><p><code>firstElementChild</code> 属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.firstElementChild.nodeName</span><br><span class="line"><span class="comment">// "HTML"</span></span><br></pre></td></tr></table></figure>

<p><code>lastElementChild</code> 属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.lastElementChild.nodeName</span><br><span class="line"><span class="comment">// "HTML"</span></span><br></pre></td></tr></table></figure>

<h3 id="ParentNode-append-，ParentNode-prepend"><a href="#ParentNode-append-，ParentNode-prepend" class="headerlink" title="ParentNode.append()，ParentNode.prepend()"></a>ParentNode.append()，ParentNode.prepend()</h3><p><code>append</code> 方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。</p>
<p>该方法不仅可以添加元素子节点，还可以添加文本子节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.body;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素子节点</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">parent.append(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文本子节点</span></span><br><span class="line">parent.append(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加多个元素子节点</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">parent.append(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素子节点和文本子节点</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">parent.append(<span class="string">'Hello'</span>, p);</span><br></pre></td></tr></table></figure>

<p>注意，该方法没有返回值。</p>
<p><code>prepend</code> 方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与 append 方法完全一致，也是没有返回值。</p>
<h2 id="ChildNode-接口"><a href="#ChildNode-接口" class="headerlink" title="ChildNode 接口"></a>ChildNode 接口</h2><p>如果一个节点有父节点，那么该节点就拥有了 ChildNode 接口。</p>
<h3 id="ChildNode-remove"><a href="#ChildNode-remove" class="headerlink" title="ChildNode.remove()"></a>ChildNode.remove()</h3><p>remove 方法用于从父节点移除当前节点。（移除的是当前节点，也就是自己）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.remove()</span><br></pre></td></tr></table></figure>

<p>上面代码在 DOM 里面移除了 <code>el</code> 节点。</p>
<h3 id="ChildNode-before-，ChildNode-after"><a href="#ChildNode-before-，ChildNode-after" class="headerlink" title="ChildNode.before()，ChildNode.after()"></a>ChildNode.before()，ChildNode.after()</h3><p><code>before</code> 方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。</p>
<p>注意，该方法不仅可以插入元素节点，还可以插入文本节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素节点</span></span><br><span class="line">el.before(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入文本节点</span></span><br><span class="line">el.before(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入多个元素节点</span></span><br><span class="line">el.before(p, p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素节点和文本节点</span></span><br><span class="line">el.before(p, <span class="string">'Hello'</span>);</span><br></pre></td></tr></table></figure>

<p><code>after</code> 方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与 <code>before</code> 方法完全相同。</p>
<h3 id="ChildNode-replaceWith"><a href="#ChildNode-replaceWith" class="headerlink" title="ChildNode.replaceWith()"></a>ChildNode.replaceWith()</h3><p><code>replaceWith</code> 方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>);</span><br><span class="line">el.replaceWith(span);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>el</code> 节点将被 <code>span</code> 节点替换。</p>
<hr>
<h1 id="Document-节点"><a href="#Document-节点" class="headerlink" title="Document 节点"></a>Document 节点</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><code>document</code> 节点对象代表整个文档，每张网页都有自己的 <code>document</code> 对象。<code>window.document</code> 属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。</p>
<h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><h3 id="document-doctype"><a href="#document-doctype" class="headerlink" title="document.doctype"></a>document.doctype</h3><p><code>document.doctype</code>，指向 <code>&lt;DOCTYPE&gt;</code> 节点，即文档类型（Document Type Declaration，简写DTD）节点。</p>
<h3 id="document-body，document-head"><a href="#document-body，document-head" class="headerlink" title="document.body，document.head"></a>document.body，document.head</h3><p><code>document.body</code> 属性指向 <code>&lt;body&gt;</code> 节点，<code>document.head</code> 属性指向 <code>&lt;head&gt;</code> 节点。</p>
<h3 id="document-documentURI，document-URL"><a href="#document-documentURI，document-URL" class="headerlink" title="document.documentURI，document.URL"></a>document.documentURI，document.URL</h3><p><code>document.documentURI</code> 属性和 <code>document.URL</code> 属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，<code>documentURI</code> 继承自 <code>Document</code> 接口，可用于所有文档；<code>URL</code> 继承自 <code>HTMLDocument</code> 接口，只能用于 <code>HTML</code> 文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.URL</span><br><span class="line"><span class="comment">// http://www.example.com/about</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentURI === <span class="built_in">document</span>.URL</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="document-location"><a href="#document-location" class="headerlink" title="document.location"></a>document.location</h3><p>Location 对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过 <code>window.location</code> 和 <code>document.location</code> 属性，可以拿到这个对象。</p>
<h3 id="document-title"><a href="#document-title" class="headerlink" title="document.title"></a>document.title</h3><p><code>document.title</code> 属性返回当前文档的标题。默认情况下，返回 <code>&lt;title&gt;</code> 节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.title = <span class="string">'新标题'</span>;</span><br><span class="line"><span class="built_in">document</span>.title <span class="comment">// "新标题"</span></span><br></pre></td></tr></table></figure>

<h3 id="document-readyState"><a href="#document-readyState" class="headerlink" title="document.readyState"></a>document.readyState</h3><p><code>document.readyState</code> 属性返回当前文档的状态，共有三种可能的值。</p>
<ul>
<li>loading：加载 HTML 代码阶段（尚未完成解析）</li>
<li>interactive：加载外部资源阶段</li>
<li>complete：加载完成</li>
</ul>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><code>document</code> 对象继承了 <code>EventTarget</code> 接口和 <code>Node</code> 接口，并且混入（<code>mixin</code>）了 <code>ParentNode</code> 接口。这意味着，这些接口的方法都可以在 <code>document</code> 对象上调用。除此之外，<code>document</code> 对象还有很多自己的属性和方法。</p>
<h3 id="获取元素相关方法"><a href="#获取元素相关方法" class="headerlink" title="获取元素相关方法"></a>获取元素相关方法</h3><h4 id="document-querySelector-，document-querySelectorAll"><a href="#document-querySelector-，document-querySelectorAll" class="headerlink" title="document.querySelector()，document.querySelectorAll()"></a>document.querySelector()，document.querySelectorAll()</h4><p><code>document.querySelector</code> 方法接受一个 <code>CSS</code> 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则 ==返回第一个匹配的节点==。如果没有发现匹配的节点，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el1 = <span class="built_in">document</span>.querySelector(<span class="string">'.myclass'</span>);</span><br><span class="line"><span class="keyword">var</span> el2 = <span class="built_in">document</span>.querySelector(<span class="string">'#myParent &gt; [ng-click]'</span>);</span><br></pre></td></tr></table></figure>

<p><code>document.querySelectorAll</code> 方法与 <code>querySelector</code> 用法类似，==区别是返回一个 <code>NodeList</code> 对象，包含所有匹配给定选择器的节点。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.myclass'</span>);</span><br></pre></td></tr></table></figure>

<p>这两个方法除了定义在 <code>document</code> 对象上，还定义在元素节点上，即==在元素节点上也可以调用。==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el1 &#x3D; document.querySelector(&#39;.myclass&#39;);</span><br><span class="line">var el2 &#x3D; el1.querySelector(&#39;p&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="document-getElementsByTagName"><a href="#document-getElementsByTagName" class="headerlink" title="document.getElementsByTagName()"></a>document.getElementsByTagName()</h4><p><code>document.getElementsByTagName()</code> 方法搜索 HTML 标签名，返回符合条件的元素。它的==返回值是一个类似数组对象（HTMLCollection实例）==，可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paras = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>);</span><br><span class="line">paras <span class="keyword">instanceof</span> HTMLCollection <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>元素节点本身也定义了 <code>getElementsByTagName</code> 方法，返回该元素的后代元素中符合条件的元素。这个方法不仅可以在 <code>document</code> 对象上调用，也可以在任何元素节点上调用。</p>
<h4 id="document-getElementsByClassName"><a href="#document-getElementsByClassName" class="headerlink" title="document.getElementsByClassName()"></a>document.getElementsByClassName()</h4><p><code>document.getElementsByClassName()</code> 方法返回一个类似数组的对象（HTMLCollection实例），包括了所有 <code>class</code> 名字符合指定条件的元素，元素的变化实时反映在返回结果中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByClassName(names);</span><br></pre></td></tr></table></figure>

<p>由于 <code>class</code> 是保留字，所以 JavaScript 一律使用 <code>className</code> 表示 <code>CSS</code> 的 <code>class</code>。</p>
<p>参数可以是多个 <code>class</code>，它们之间使用空格分隔。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'foo bar'</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码返回==同时具有 <code>foo</code> 和 <code>bar</code> 两个 <code>class</code> 的元素，<code>foo</code> 和 <code>bar</code> 的顺序不重要。</p>
<p>注意，正常模式下，CSS 的 <code>class</code> 是大小写敏感的。（quirks mode下，大小写不敏感。）</p>
<p>与 <code>getElementsByTagName()</code> 方法一样，<code>getElementsByClassName()</code> 方法不仅可以在 <code>document</code> 对象上调用，也可以在任何元素节点上调用。</p>
<h4 id="document-getElementById"><a href="#document-getElementById" class="headerlink" title="document.getElementById()"></a>document.getElementById()</h4><p><code>document.getElementById()</code> 方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">'para1'</span>);</span><br></pre></td></tr></table></figure>

<h4 id="document-elementFromPoint-，document-elementsFromPoint"><a href="#document-elementFromPoint-，document-elementsFromPoint" class="headerlink" title="document.elementFromPoint()，document.elementsFromPoint()"></a>document.elementFromPoint()，document.elementsFromPoint()</h4><p><code>document.elementFromPoint()</code> 方法返回位于页面指定位置最上层的元素节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.elementFromPoint(<span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码选中在(50, 50)这个坐标位置的最上层的那个 HTML 元素。</p>
<p><code>elementFromPoint</code> 方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的 HTML 元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回 <code>null</code>。</p>
<p><code>document.elementsFromPoint()</code> 返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.elementsFromPoint(x, y);</span><br></pre></td></tr></table></figure>

<h3 id="创建元素、属性等方法"><a href="#创建元素、属性等方法" class="headerlink" title="创建元素、属性等方法"></a>创建元素、属性等方法</h3><h4 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h4><p><code>document.createElement</code> 方法用来生成元素节点，并返回该节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure>

<p><code>createElement</code> 方法的参数为元素的标签名，即元素节点的 <code>tagName</code> 属性，对于 HTML 网页大小写不敏感，即参数为 <code>div</code> 或 <code>DIV</code> 返回的是同一种节点。如果参数里面包含尖括号（即&lt;和&gt;）会报错。<code>document.createElement</code> 的参数可以是自定义的标签名。</p>
<h4 id="document-createTextNode"><a href="#document-createTextNode" class="headerlink" title="document.createTextNode()"></a>document.createTextNode()</h4><p><code>document.createTextNode</code> 方法用来生成文本节点（<code>Text</code>实例），并返回该节点。它的参数是文本节点的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> newContent = <span class="built_in">document</span>.createTextNode(<span class="string">'Hello'</span>);</span><br><span class="line">newDiv.appendChild(newContent);</span><br></pre></td></tr></table></figure>

<p>上面代码新建一个 <code>div</code> 节点和一个文本节点，然后将文本节点插入 <code>div</code> 节点。</p>
<h4 id="document-createAttribute"><a href="#document-createAttribute" class="headerlink" title="document.createAttribute()"></a>document.createAttribute()</h4><p><code>document.createAttribute</code> 方法生成一个新的属性节点（<code>Attr</code>实例），并返回它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attribute = <span class="built_in">document</span>.createAttribute(name);</span><br><span class="line"><span class="built_in">document</span>.createAttribute方法的参数name，是属性的名称。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> node = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createAttribute(<span class="string">'my_attrib'</span>);</span><br><span class="line">a.value = <span class="string">'newVal'</span>;</span><br><span class="line"></span><br><span class="line">node.setAttributeNode(a);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">node.setAttribute(<span class="string">'my_attrib'</span>, <span class="string">'newVal'</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码为 <code>div1</code> 节点，插入一个值为 <code>newVal</code> 的 <code>my_attrib</code> 属性。</p>
<h4 id="document-createComment"><a href="#document-createComment" class="headerlink" title="document.createComment()"></a>document.createComment()</h4><p><code>document.createComment</code> 方法生成一个新的注释节点，并返回该节点。</p>
<h4 id="document-createDocumentFragment"><a href="#document-createDocumentFragment" class="headerlink" title="document.createDocumentFragment()"></a>document.createDocumentFragment()</h4><p><code>document.createDocumentFragment</code> 方法生成一个空的文档片段对象（<code>DocumentFragment</code>实例）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docFragment = <span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure>

<p><code>DocumentFragment</code> 是一个存在于内存的 DOM 片段，不属于当前文档，==常常用来生成一段较复杂的 DOM 结构，然后再插入当前文档。== 这样做的==好处在于，因为 <code>DocumentFragment</code> 不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的 DOM 有更好的性能表现。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> docfrag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  li.textContent = e;</span><br><span class="line">  docfrag.appendChild(li);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> element  = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span><br><span class="line">element.appendChild(docfrag);</span><br></pre></td></tr></table></figure>

<p>上面代码中，文档片断 <code>docfrag</code> 包含四个 <code>&lt;li&gt;</code> 节点，这些子节点被一次性插入了当前文档。</p>
<h4 id="document-createEvent"><a href="#document-createEvent" class="headerlink" title="document.createEvent()"></a>document.createEvent()</h4><p><code>document.createEvent</code> 方法生成一个事件对象（Event实例），该对象可以被 <code>element.dispatchEvent</code> 方法使用，触发指定事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(type);</span><br></pre></td></tr></table></figure>

<p><code>document.createEvent</code> 方法的参数是事件类型，比如 <code>UIEvents、MouseEvents、MutationEvents、HTMLEvents</code>。</p>
<h4 id="document-addEventListener-，document-removeEventListener-，document-dispatchEvent"><a href="#document-addEventListener-，document-removeEventListener-，document-dispatchEvent" class="headerlink" title="document.addEventListener()，document.removeEventListener()，document.dispatchEvent()"></a>document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</h4><p>这三个方法用于处理 <code>document</code> 节点的事件。</p>
<h1 id="Element-节点"><a href="#Element-节点" class="headerlink" title="Element 节点"></a>Element 节点</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Element</code> 节点对象对应网页的 HTML 元素。每一个 HTML 元素，在 DOM 树上都会转化成一个 <code>Element</code> 节点对象（以下简称元素节点）。</p>
<p>元素节点的 <code>nodeType</code> 属性都是 <code>1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line">p.nodeName <span class="comment">// "P"</span></span><br><span class="line">p.nodeType <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="元素特性的相关属性"><a href="#元素特性的相关属性" class="headerlink" title="元素特性的相关属性"></a>元素特性的相关属性</h3><h4 id="Element-id"><a href="#Element-id" class="headerlink" title="Element.id"></a><code>Element.id</code></h4><p><code>Element.id</code> 属性返回指定元素的 <code>id</code> 属性，该属性可读写，大小写敏感。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为 &lt;p id="foo"&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>);</span><br><span class="line">p.id <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<h4 id="Element-tagName"><a href="#Element-tagName" class="headerlink" title="Element.tagName"></a>Element.tagName</h4><p><code>Element.tagName</code> 属性返回指定元素的大写标签名，与 <code>nodeName</code> 属性的值相等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML代码为</span></span><br><span class="line"><span class="comment">// &lt;span id="myspan"&gt;Hello&lt;/span&gt;</span></span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.getElementById(<span class="string">'myspan'</span>);</span><br><span class="line">span.id <span class="comment">// "myspan"</span></span><br><span class="line">span.tagName <span class="comment">// "SPAN"</span></span><br></pre></td></tr></table></figure>

<h4 id="Element-title"><a href="#Element-title" class="headerlink" title="Element.title"></a>Element.title</h4><p><code>Element.title</code> 属性用来读写当前元素的 HTML 属性 <code>title</code>。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</p>
<h3 id="元素状态的相关属性"><a href="#元素状态的相关属性" class="headerlink" title="元素状态的相关属性"></a>元素状态的相关属性</h3><h4 id="Element-hidden"><a href="#Element-hidden" class="headerlink" title="Element.hidden"></a>Element.hidden</h4><p><code>Element.hidden</code> 属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。该属性可读写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"><span class="keyword">var</span> mydiv = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  mydiv.hidden = !mydiv.hidden;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>注意，该属性与 CSS 设置是互相独立的。CSS 对这个元素可见性的设置，<code>Element.hidden</code> 并不能反映出来。也就是说，这个属性并不能用来判断当前元素的实际可见性。</p>
<h3 id="Element-attributes"><a href="#Element-attributes" class="headerlink" title="Element.attributes"></a>Element.attributes</h3><p><code>Element.attributes</code> 属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点。</p>
<h3 id="Element-className，Element-classList"><a href="#Element-className，Element-classList" class="headerlink" title="Element.className，Element.classList"></a>Element.className，Element.classList</h3><p><code>className</code> 属性用来读写当前元素节点的 <code>class</code> 属性。它的值是一个字符串，每个 <code>class</code> 之间用空格分割。</p>
<p><code>classList</code> 属性返回一个类似数组的对象，当前元素节点的每个 <code>class</code> 就是这个对象的一个成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码 &lt;div class="one two three" id="myDiv"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"></span><br><span class="line">div.className</span><br><span class="line"><span class="comment">// "one two three"</span></span><br><span class="line"></span><br><span class="line">div.classList</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   0: "one"</span></span><br><span class="line"><span class="comment">//   1: "two"</span></span><br><span class="line"><span class="comment">//   2: "three"</span></span><br><span class="line"><span class="comment">//   length: 3</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>classList</code> 对象有下列方法。</p>
<ul>
<li>add()：增加一个 class。</li>
<li>remove()：移除一个 class。</li>
<li>contains()：检查当前元素是否包含某个 class。</li>
<li>toggle()：将某个 class 移入或移出当前元素。</li>
<li>item()：返回指定索引位置的 class。</li>
<li>toString()：将 class 的列表转为字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line"></span><br><span class="line">div.classList.add(<span class="string">'myCssClass'</span>);</span><br><span class="line">div.classList.add(<span class="string">'foo'</span>, <span class="string">'bar'</span>);</span><br><span class="line">div.classList.remove(<span class="string">'myCssClass'</span>);</span><br><span class="line">div.classList.toggle(<span class="string">'myCssClass'</span>); <span class="comment">// 如果 myCssClass 不存在就加入，否则移除</span></span><br><span class="line">div.classList.contains(<span class="string">'myCssClass'</span>); <span class="comment">// 返回 true 或者 false</span></span><br><span class="line">div.classList.item(<span class="number">0</span>); <span class="comment">// 返回第一个 Class</span></span><br><span class="line">div.classList.toString();</span><br></pre></td></tr></table></figure>

<h3 id="Element-dataset"><a href="#Element-dataset" class="headerlink" title="Element.dataset"></a>Element.dataset</h3><p>网页元素可以自定义 <code>data-</code> 属性，用来添加数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-timestamp</span>=<span class="string">"1522907809292"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>Element.dataset</code> 属性返回一个对象，可以从这个对象读写 <code>data-</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;article</span></span><br><span class="line"><span class="comment">//   id="foo"</span></span><br><span class="line"><span class="comment">//   data-columns="3"</span></span><br><span class="line"><span class="comment">//   data-index-number="12314"</span></span><br><span class="line"><span class="comment">//   data-parent="cars"&gt;</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">// &lt;/article&gt;</span></span><br><span class="line"><span class="keyword">var</span> article = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span><br><span class="line">article.dataset.columns <span class="comment">// "3"</span></span><br><span class="line">article.dataset.indexNumber <span class="comment">// "12314"</span></span><br><span class="line">article.dataset.parent <span class="comment">// "cars"</span></span><br></pre></td></tr></table></figure>

<h3 id="Element-innerHTML"><a href="#Element-innerHTML" class="headerlink" title="Element.innerHTML"></a>Element.innerHTML</h3><p><code>Element.innerHTML</code> 属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括 <code>&lt;HTML&gt;</code> 和 <code>&lt;body&gt;</code> 元素。</p>
<p>==如果将 <code>innerHTML</code> 属性设为空，等于删除所有它包含的所有节点。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.innerHTML = <span class="string">''</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Element-outerHTML"><a href="#Element-outerHTML" class="headerlink" title="Element.outerHTML"></a>Element.outerHTML</h3><p><code>Element.outerHTML</code> 属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码如下</span></span><br><span class="line"><span class="comment">// &lt;div id="d"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">document</span>.getElementById(<span class="string">'d'</span>);</span><br><span class="line">d.outerHTML</span><br><span class="line"><span class="comment">// '&lt;div id="d"&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>

<p><code>outerHTML</code> 属性是可读写的，对它进行赋值，等于替换掉当前元素。</p>
<p>注意，==如果一个节点没有父节点，设置 <code>outerHTML</code> 属性会报错。==</p>
<h3 id="Element-clientHeight，Element-clientWidth"><a href="#Element-clientHeight，Element-clientWidth" class="headerlink" title="Element.clientHeight，Element.clientWidth"></a>Element.clientHeight，Element.clientWidth</h3><p><code>Element.clientHeight/Element.clientWidth</code> 属性返回一个整数值，表示元素节点的 CSS 高/宽度（单位像素），只对块级元素生效，对于行内元素返回 <code>0</code>。如果块级元素没有设置 CSS 高/宽度，则返回实际高/宽度。</p>
<p>除了元素本身的高度，它还包括 <code>padding</code> 部分，但是不包括 <code>border、margin</code>。如果有水平/垂直滚动条，还要减去水平/垂直滚动条的高度。注意，这个值始终是整数，如果是小数会被四舍五入。</p>
<h3 id="Element-clientLeft，Element-clientTop"><a href="#Element-clientLeft，Element-clientTop" class="headerlink" title="Element.clientLeft，Element.clientTop"></a>Element.clientLeft，Element.clientTop</h3><p><code>Element.clientLeft</code> 属性等于元素节点左边框（left border）的宽度（单位像素），不包括左侧的 <code>padding</code> 和 <code>margin</code>。如果没有设置左边框，或者是行内元素（<code>display: inline</code>），该属性返回 <code>0</code>。该属性总是返回整数值，如果是小数，会四舍五入。</p>
<p><code>Element.clientTop</code> 属性等于网页元素顶部边框的宽度（单位像素），其他特点都与 <code>clientLeft</code> 相同。</p>
<h3 id="Element-scrollHeight，Element-scrollWidth"><a href="#Element-scrollHeight，Element-scrollWidth" class="headerlink" title="Element.scrollHeight，Element.scrollWidth"></a>Element.scrollHeight，Element.scrollWidth</h3><p><code>Element.scrollHeight</code> 属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。它包括 <code>padding</code>，但是不包括 <code>border、margin</code> 以及水平滚动条的高度（如果有水平滚动条的话），还包括伪元素（<code>::before</code> 或 <code>::after</code>）的高度。</p>
<p><code>Element.scrollWidth</code> 属性表示当前元素的总宽度（单位像素），其他地方都与 <code>scrollHeight</code> 属性类似。这两个属性只读。</p>
<p>整张网页的总高度可以从 <code>document.documentElement</code> 或 <code>document.body</code> 上读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回网页的总高度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.scrollHeight</span><br><span class="line"><span class="built_in">document</span>.body.scrollHeight</span><br></pre></td></tr></table></figure>

<h3 id="Element-scrollLeft，Element-scrollTop"><a href="#Element-scrollLeft，Element-scrollTop" class="headerlink" title="Element.scrollLeft，Element.scrollTop"></a>Element.scrollLeft，Element.scrollTop</h3><p><code>Element.scrollLeft</code> 属性表示当前元素的水平滚动条向右侧滚动的像素数量，<code>Element.scrollTop</code> 属性表示当前元素的垂直滚动条向下滚动的像素数量。</p>
<h3 id="Element-offsetHeight，Element-offsetWidth"><a href="#Element-offsetHeight，Element-offsetWidth" class="headerlink" title="Element.offsetHeight，Element.offsetWidth"></a>Element.offsetHeight，Element.offsetWidth</h3><p><code>Element.offsetHeight</code> 属性返回一个整数，表示元素的 CSS 垂直高度（单位像素），包括元素本身的高度、<code>padding</code> 和 <code>border</code>，以及水平滚动条的高度（如果存在滚动条）。</p>
<p><code>Element.offsetWidth</code> 属性表示元素的 CSS 水平宽度（单位像素），其他都与 <code>Element.offsetHeight</code> 一致。</p>
<p>==这两个属性都是只读属性，只比 <code>Element.clientHeight</code> 和 <code>Element.clientWidth</code> 多了边框的高度或宽度。如果元素的 CSS 设为不可见（比如 <code>display: none;</code>），则返回 <code>0</code>。==</p>
<h3 id="Element-offsetLeft，Element-offsetTop"><a href="#Element-offsetLeft，Element-offsetTop" class="headerlink" title="Element.offsetLeft，Element.offsetTop"></a>Element.offsetLeft，Element.offsetTop</h3><p><code>Element.offsetLeft</code> 返回当前元素左上角相对于 <code>Element.offsetParent</code> 节点的水平位移，<code>Element.offsetTop</code> 返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。</p>
<h3 id="Element-children，Element-childElementCount"><a href="#Element-children，Element-childElementCount" class="headerlink" title="Element.children，Element.childElementCount"></a>Element.children，Element.childElementCount</h3><p><code>Element.children</code> 属性返回一个类似数组的对象（HTMLCollection实例），包括当前元素节点的所有子元素。</p>
<p>这个属性与 <code>Node.childNodes</code> 属性的区别是，它==只包括元素类型的子节点，不包括其他类型的子节点。==</p>
<h3 id="Element-firstElementChild，Element-lastElementChild"><a href="#Element-firstElementChild，Element-lastElementChild" class="headerlink" title="Element.firstElementChild，Element.lastElementChild"></a>Element.firstElementChild，Element.lastElementChild</h3><p><code>Element.firstElementChild</code> 属性返回当前元素的第一个元素子节点，<code>Element.lastElementChild</code> 返回最后一个元素子节点。</p>
<h3 id="Element-nextElementSibling，Element-previousElementSibling"><a href="#Element-nextElementSibling，Element-previousElementSibling" class="headerlink" title="Element.nextElementSibling，Element.previousElementSibling"></a>Element.nextElementSibling，Element.previousElementSibling</h3><p><code>Element.nextElementSibling</code> 属性返回当前元素节点的后一个同级元素节点，如果没有则返回 <code>null</code>。</p>
<p><code>Element.previousElementSibling</code> 属性返回当前元素节点的前一个同级元素节点，如果没有则返回 <code>null</code>。</p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="属性相关方法"><a href="#属性相关方法" class="headerlink" title="属性相关方法"></a>属性相关方法</h3><p>元素节点提供六个方法，用来操作属性。</p>
<ul>
<li>getAttribute()：读取某个属性的值</li>
<li>getAttributeNames()：返回当前元素的所有属性名</li>
<li>setAttribute()：写入属性值</li>
<li>hasAttribute()：某个属性是否存在</li>
<li>hasAttributes()：当前元素是否有属性</li>
<li>removeAttribute()：删除属性</li>
</ul>
<h3 id="Element-querySelector"><a href="#Element-querySelector" class="headerlink" title="Element.querySelector()"></a>Element.querySelector()</h3><p><code>Element.querySelector</code> 方法接受 CSS 选择器作为参数，==返回父元素的第一个匹配的子元素。==</p>
<h3 id="Element-querySelectorAll"><a href="#Element-querySelectorAll" class="headerlink" title="Element.querySelectorAll()"></a>Element.querySelectorAll()</h3><p><code>Element.querySelectorAll</code> 方法接受 CSS 选择器作为参数，返回一个 <code>NodeList</code> 实例，包含所有匹配的子元素。</p>
<h3 id="Element-getElementsByClassName"><a href="#Element-getElementsByClassName" class="headerlink" title="Element.getElementsByClassName()"></a>Element.getElementsByClassName()</h3><p><code>Element.getElementsByClassName</code> 方法返回一个 HTMLCollection 实例，成员是当前元素节点的所有具有指定 <code>class</code> 的子元素节点。</p>
<p>Element.getElementsByTagName()</p>
<p><code>Element.getElementsByTagName()</code> 方法返回一个 <code>HTMLCollection</code> 实例，成员是当前节点的所有匹配指定标签名的子元素节点。</p>
<h3 id="事件相关方法"><a href="#事件相关方法" class="headerlink" title="事件相关方法"></a>事件相关方法</h3><p>以下三个方法与 <code>Element</code> 节点的事件相关。这些方法都继承自 <code>EventTarget</code> 接口。</p>
<ul>
<li>Element.addEventListener()：添加事件的回调函数</li>
<li>Element.removeEventListener()：移除事件监听函数</li>
<li>Element.dispatchEvent()：触发事件</li>
</ul>
<h3 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="Element.scrollIntoView()"></a>Element.scrollIntoView()</h3><p><code>Element.scrollIntoView</code> 方法滚动当前元素，进入浏览器的可见区域，类似于设置 <code>window.location.hash</code> 的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">el.scrollIntoView(); <span class="comment">// 等同于el.scrollIntoView(true)</span></span><br><span class="line">el.scrollIntoView(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>参数如果为 <code>true</code>，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为 <code>false</code>，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为 <code>true</code>。</p>
<h3 id="Element-remove"><a href="#Element-remove" class="headerlink" title="Element.remove()"></a>Element.remove()</h3><p><code>Element.remove</code> 方法继承自 <code>ChildNode</code> 接口，用于将当前元素节点从它的父节点移除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line">el.remove();</span><br></pre></td></tr></table></figure>

<p>上面代码将 <code>el</code> 节点从 DOM 树里面移除。</p>
<h3 id="Element-focus-，Element-blur"><a href="#Element-focus-，Element-blur" class="headerlink" title="Element.focus()，Element.blur()"></a>Element.focus()，Element.blur()</h3><p><code>Element.focus</code> 方法用于将当前页面的焦点，转移到指定元素上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'my-span'</span>).focus();</span><br></pre></td></tr></table></figure>

<p><code>Element.blur</code> 方法用于将焦点从当前元素移除。</p>
<h3 id="Element-click"><a href="#Element-click" class="headerlink" title="Element.click()"></a>Element.click()</h3><p><code>Element.click</code> 方法用于在当前元素上模拟一次鼠标点击，相当于触发了 <code>click</code> 事件。</p>
<hr>
<h1 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h1><p>HTML 元素包括标签名和若干个键值对，这个键值对就称为“属性”（attribute）。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">href</span>=<span class="string">"http://www.example.com"</span>&gt;</span></span><br><span class="line">  链接</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code> 元素包括两个属性：<code>id</code> 属性和 <code>href</code> 属性。</p>
<h2 id="Element-attributes-属性"><a href="#Element-attributes-属性" class="headerlink" title="Element.attributes 属性"></a>Element.attributes 属性</h2><p>==元素对象==有一个 <code>attributes</code> 属性，返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上。</p>
<p>其他类型的节点对象，虽然也有 <code>attributes</code> 属性，但返回的都是 <code>null</code>，因此可以把这个属性视为元素对象独有的。</p>
<h2 id="元素的标准属性"><a href="#元素的标准属性" class="headerlink" title="元素的标准属性"></a>元素的标准属性</h2><p>HTML 元素的标准属性（即在标准中定义的属性），会自动成为元素节点对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'test'</span>);</span><br><span class="line">a.id <span class="comment">// "test"</span></span><br><span class="line">a.href <span class="comment">// "http://www.example.com/"</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code> 元素标签的属性 <code>id</code> 和 <code>href</code>，自动成为节点对象的属性。</p>
<p>==这些属性都是可写的，这种用法虽然可以读写属性，但是无法删除属性，delete运算符在这里不会生效。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">'myImage'</span>);</span><br><span class="line">img.src = <span class="string">'http://www.example.com/image.jpg'</span>;</span><br></pre></td></tr></table></figure>

<h2 id="属性操作的标准方法"><a href="#属性操作的标准方法" class="headerlink" title="属性操作的标准方法"></a>属性操作的标准方法</h2><h3 id="Element-getAttribute"><a href="#Element-getAttribute" class="headerlink" title="Element.getAttribute()"></a>Element.getAttribute()</h3><p><code>Element.getAttribute</code> 方法返回当前元素节点的指定属性。如果指定属性不存在，则返回 <code>null</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;div id="div1" align="left"&gt;</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">div.getAttribute(<span class="string">'align'</span>) <span class="comment">// "left"</span></span><br></pre></td></tr></table></figure>

<h3 id="Element-getAttributeNames"><a href="#Element-getAttributeNames" class="headerlink" title="Element.getAttributeNames()"></a>Element.getAttributeNames()</h3><p><code>Element.getAttributeNames()</code> 返回一个数组，成员是当前元素的所有属性的名字。如果当前元素没有任何属性，则返回一个空数组。</p>
<h3 id="Element-setAttribute"><a href="#Element-setAttribute" class="headerlink" title="Element.setAttribute()"></a>Element.setAttribute()</h3><p><code>Element.setAttribute</code> 方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。该方法没有返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML 代码为</span></span><br><span class="line"><span class="comment">// &lt;button&gt;Hello World&lt;/button&gt;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line">b.setAttribute(<span class="string">'name'</span>, <span class="string">'myButton'</span>);</span><br><span class="line">b.setAttribute(<span class="string">'disabled'</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Element-hasAttribute"><a href="#Element-hasAttribute" class="headerlink" title="Element.hasAttribute()"></a>Element.hasAttribute()</h3><p><code>Element.hasAttribute</code> 方法返回一个布尔值，表示当前元素节点是否包含==指定属性。==</p>
<h3 id="Element-hasAttributes"><a href="#Element-hasAttributes" class="headerlink" title="Element.hasAttributes()"></a>Element.hasAttributes()</h3><p><code>Element.hasAttributes</code> 方法返回一个布尔值，表示当前元素是否有属性，如果没有任何属性，就返回 <code>false</code>，否则返回 <code>true</code>。</p>
<h3 id="Element-removeAttribute"><a href="#Element-removeAttribute" class="headerlink" title="Element.removeAttribute()"></a>Element.removeAttribute()</h3><p><code>Element.removeAttribute</code> 方法移除指定属性。</p>
<h2 id="dataset-属性"><a href="#dataset-属性" class="headerlink" title="dataset 属性"></a>dataset 属性</h2><p>使用标准提供的 <code>data-*</code> 属性在 <code>HTML</code> 元素上附加数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mydiv"</span> <span class="attr">data-foo</span>=<span class="string">"bar"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用元素节点对象的 <code>dataset</code>  属性，它指向一个对象，可以用来操作 HTML 元素标签的 <code>data-*</code> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">document</span>.getElementById(<span class="string">'mydiv'</span>);</span><br><span class="line">n.dataset.foo <span class="comment">// bar</span></span><br><span class="line">n.dataset.foo = <span class="string">'baz'</span></span><br></pre></td></tr></table></figure>

<p>除了 <code>dataset</code> 属性，也可以用 <code>getAttribute(&#39;data-foo&#39;)、removeAttribute(&#39;data-foo&#39;)、setAttribute(&#39;data-foo&#39;)、hasAttribute(&#39;data-foo&#39;)</code> 等方法操作 <code>data-*</code> 属性。</p>
<p>注意，data-后面的属性名有限制，只能包含字母、数字、连词线（<code>-</code>）、点（<code>.</code>）、冒号（<code>:</code>）和下划线（<code>_</code>)。而且，属性名不应该使用 <code>A</code> 到 <code>Z</code> 的大写字母，比如不能有 <code>data-helloWorld</code> 这样的属性名，而要写成 <code>data-hello-world</code>。</p>
<hr>
<h1 id="CSS-操作"><a href="#CSS-操作" class="headerlink" title="CSS 操作"></a>CSS 操作</h1><p>CSS 与 JavaScript 是两个有着明确分工的领域。有时候还会不可避免交叉相互配合，下面介绍几个常用的 JavaScript 操作 CSS 的方法。</p>
<p>HTML 元素的 style 属性</p>
<p>操作 CSS 样式最简单的方法，就是使用网页元素节点的 getAttribute（）方法、setAttribute（）方法和 removeAttribute（）方法，直接读写或者删除网页元素的 style 属性。</p>
<p>div.setAttribute(‘style’,’background-color:red;’+’border:1px solid black;’)</p>
<p>以上代码相当于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background-color:red;border:1px solid black;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>style 不仅可以使用字符串读写，style 本身也是一个对象，部署了 CSSStyleDeclaration 接口，可以直接读写个别属性。</p>
<p>e.style.fontSize = ‘18px’;<br>e.style.color = ‘black’;</p>
<p>CSSStyleDeclaration 接口</p>
<p>元素节点的 style 属性（element.style）部署了该接口，可以直接读写 CSS 的样式属性，不过，连词号需要变成驼峰拼写法。</p>
<p>var divStyle = document.querySelector(‘div’).style;</p>
<p>divStyle.backgroundColor = ‘red’;<br>divStyle.border = ‘1px solid black’;<br>divStyle.width = ‘100px’;<br>divStyle.height = ‘100px’;<br>divStyle.fontSize = ‘10em’;</p>
<p>divStyle.backgroundColor // red<br>divStyle.border // 1px solid black<br>divStyle.height // 100px<br>divStyle.width // 100px</p>
<hr>
<h1 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h1><p>DOM 的事件操作（监听和触发），都定义在 EventTarget 接口。所有节点对象都部署了这个接口，其它一些需要事件通信的浏览器内置对象（比如，XMLHttpRequest、AudioNode、AudioContext）也部署了这个接口。</p>
<p>该接口主要提供 3 个实例方法：</p>
<p>addEventListener：绑定事件的监听函数<br>removeEventListener：移除事件的监听函数<br>dispatchEvent：触发事件</p>
<p>EventTarget.addEventListener（）</p>
<p>EventTarget.addEventListener（）用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</p>
<p>target.addEventListener（type,listener,useCapture）</p>
<p>该方法接受三个参数：</p>
<p>type：事件名称，大小写敏感<br>listener：监听函数。事件发生时，会调用该监听函数<br>useCapture：布尔值，表示监听函数是否在捕获阶段触发，默认为 false （监听函数只在冒泡阶段触发）。该参数可选。</p>
<p>function hello(){<br>    console.log(‘Hello world’);<br>}</p>
<p>var button = document.getElementById(‘btn’);<br>button.addEventListener(‘click’,hello,false);</p>
<p>上述案例，button 节点的 addEventListener 方法绑定 click 事件的监听函数 hello，该函数只在冒泡阶段触发。</p>
<p>第二个参数除了监听函数，还可以是一个具有 handleEvent 方法的对象。</p>
<p>buttonElement.addEventListener(‘click’,{<br>    handleEvent:function(event){<br>        console.log(‘click);<br>    }<br>});</p>
<p>第三个参数除了布尔值 useCapture，还可以是一个属性配置对象。该对象有以下属性：</p>
<p>capture：布尔值，表示该事件是否在捕获阶段触发监听函数<br>once：布尔值，表示监听函数是否只触发一次，然后自动移除<br>passive：布尔值，表示监听函数不会调用事件的 preventDefault 方法。</p>
<p>element.addEventListener(‘click’,function(event){<br>    // 只执行一次的代码<br>},{once:true})</p>
<p>addEventListener 方法可以针对当前的对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加的先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除（不必使用removeEventListener方法手动去除）。</p>
<p>EventTarget.removeEventListener（）</p>
<p>EventTarget.removeEventListener 方法用来移除 addEventListener 方法添加的事件监听函数，该方法没有返回值。</p>
<p>div.addEventListener(‘click’,listener,false);<br>div.removeEventListener(‘click’,listener,false);</p>
<p>removeEventListener方法的参数，与addEventListener方法完全一致。它的第一个参数“事件类型”，大小写敏感。</p>
<p>注意，removeEventListener方法移除的监听函数，必须是addEventListener方法添加的那个监听函数，而且必须在同一个元素节点，否则无效。</p>
<p>EventTarget.dispatchEvent（）</p>
<p>EventTarget.dispatchEvent 方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了 Event.preventDefault（），则返回 false，否则为 true。</p>
<p>target.dispatchEvent(event)</p>
<p>despatchEvent 方法的参数是一个 Event 对象的实例。</p>
<p>para.addEventListener(‘click’,hello,false);</p>
<p>var event = new Event(‘click’);</p>
<p>para.dispatchEvent(event);</p>
<p>上面代码在当前节点触发了 click 事件。</p>
<hr>
<h1 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h1><p>浏览器的事件模型，就是通过监听函数对事件做出反应。事件发生后，浏览器监听到了这几个事件，就会执行对应的监听函数。这是事件驱动编程模式的主要编程方式。</p>
<p>JavaScript 有三种方法，可以为事件绑定监听函数。</p>
<p>方法一：HTML 的 on- 属性</p>
<p>HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</p>
<body onload="doSomethind()">
<div onclick="console.log('触发事件')">


<p>元素的事件监听属性，都是 on 加上事件名。</p>
<p>注意，这些属性的值是将会执行的代码，而不是一个函数。</p>
<p>// 正确</p>
<body onload="doSomething()">

<p>//错误</p>
<body onload="doSomething">


<p>使用这个方法指定的监听代码，只会在冒泡阶段触发。</p>
<p>直接设置 on- 属性，与通过元素节点的 setAttribute 方法设置 on- 属性，效果是一样的。</p>
<p>el.setAttribute(‘onclick’,’doSomething()’);<br>// 等同于<br>// <Element onclick="doSomething()"></p>
<p>该方法违反了 HTML 与 JavaScript 代码相分离的原则，不利于代码分工，不推荐使用。</p>
<p>方法二：元素节点的事件属性</p>
<p>元素节点对象的事件属性，同样也可以指定监听函数。</p>
<p>window.onload = doSomething;</p>
<p>div.onclick = function(event){<br>    console.log(‘触发事件’);<br>}</p>
<p>使用这个方法指定的监听函数，也是只会在冒泡阶段触发。与 HTML 的 on- 属性的差别是，它的值是函数名（doSomething）,而不像后者，必须给出完整的监听代码（doSomething（））。</p>
<p>该方法缺点在于同一个事件只能定义一个监听函数，不推荐使用。</p>
<p>方法三：EventTarget.addEventListener（）</p>
<p>所有 DOM 节点实例都有 addEventListener 方法，用来为该节点定义事件的监听函数。</p>
<p>window.addEventListener(‘load’,doSomething,false);</p>
<p>该方法推荐使用，有如下优点：</p>
<p>同一个事件可以添加多个监听函数<br>能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发监听函数<br>除了 DOM 节点，其它对象（比如 window、XMLHttpRequest 等）也有这个接口，它等于是整个 JavaScript 统一的监听函数接口</p>
<p>this 的指向</p>
<p>三种方法监听函数内部的 this 指向触发事件的那个元素节点。</p>
<p><button id="btn" onclick="console.log(this.id)">点击</button><br>// btn </p>
<p>事件的传播</p>
<p>一个事件发生后，会在子元素和父元素之间传播，这种传播分为三个阶段：</p>
<p>第一阶段：从 window 对象传导到目标节点（上层传到底层），称为“捕获阶段”。<br>第二阶段：在目标节点上触发，称为“目标阶段”。<br>第三阶段：从目标节点传导回 window 对象（从底层传回上层），称为“冒泡阶段”。</p>
<p>事件的代理</p>
<p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素事件。这种方法叫做事件的代理。</p>
<p>var ul = document.querySelector(‘ul’);</p>
<p>ul.addEventListener(‘click’,function(event){<br>    if(event.target.tagName.toLowerCase() === ‘li’){<br>        // some code<br>    }<br>})</p>
<p>事件对象的 stopPropagation 方法可以使事件到某个节点为止，不再传播。</p>
<p>// 事件传播到 p 元素后，就不再向下传播了<br>p.addEventListener(‘click’,function(event){<br>    event.stopPropagation();<br>},true)</p>
<p>// 事件冒泡到 p 元素后，就不再向上冒泡了<br>p.addEventListener(‘click’,function(event){<br>    event.stopPropagation();<br>},false)</p>
<hr>
<h1 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h1><p>事件发生以后，会产生一个事件对象，作为参数传递给监听函数。浏览器原生提供一个 Event 对象，所有的事件都是这个对象的实例，或者继承了 Event.prototype 对象。此处仅做几个常用属性、方法介绍，其余略。</p>
<p>Event.currentTarget、Event.target</p>
<p>事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的原始触发节点（Event.target），另一个是事件当前正在通过的节点（Event.currentTarget）。前者通常是后者的后代节点。</p>
<p>Event.currentTarget 属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。</p>
<p>Event.target 属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</p>
<p>// HTML 代码为<br>// <p id="para">Hello <em>World</em></p></p>
<p>function hide(e){<br>    // 不管点击 Hello 或 World，总是返回 true<br>    console.log(this === e.currenttTarget)</p>
<pre><code>// 点击 Hello，返回 true
// 点击 World，返回 false
console.log(this === e.target)</code></pre><p>}</p>
<p>document.getElementById(‘para’).addEventListener(‘click’hide,false);</p>
<p>Event.preventDefault（）</p>
<p>Event.preventDefault 方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器会默认跳转到另一个页面，使用这个方法后就不会跳转了。该方法生效的前提是，事件对象的 cancelable 属性为 true，如果为 false，调用该方法没有任何效果。</p>
<p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用 stopPropagation（）或者 stopImmediatePropagation（）方法。</p>
<p>// HTML 代码为<br>// <input type="checkbox" id="my-checkbox" /><br>var cb = document.getElementById(‘my-checkbox’);</p>
<p>cb.addEventListener(‘click’,function(e){<br>    e.preventDefault()<br>},false)</p>
<p>上述代码，浏览器的默认行为是单击会选中单选框，取消这个行为，就会导致无法选中单选框。</p>
<p>Event.stopPropagation（）</p>
<p>stopPropagation 方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其它的事件监听函数。</p>
<p>Event.stopImmediatePropagation（）</p>
<p>Event.stopImmediatePropagation 方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比 Event.stopPropagation() 更彻底。</p>
<hr>
<h1 id="常见事件种类"><a href="#常见事件种类" class="headerlink" title="常见事件种类"></a>常见事件种类</h1><p>鼠标事件</p>
<p>click：按下鼠标（通常是按下主按钮）时触发<br>dbclick：在同一个元素上双击鼠标时触发<br>mousemove：当鼠标在一个节点内部移动时触发，当鼠标移动时，该事件会连续触发<br>mouseenter：鼠标进入一个节点时触发，进入子节点不会触发这个事件<br>mouseover：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件<br>mouseout：鼠标离开一个节点时触发，离开父节点也会触发这个事件<br>contextmenu：按下鼠标右键时（上下文菜单出现前）触发<br>wheel：滚动鼠标滚轮时触发</p>
<p>MouseEvent 接口代表了鼠标相关的事件，单击、双击、松开鼠标、拖拽滑动等。相关接口方法使用时查阅相关文档。</p>
<p>键盘事件</p>
<p>keydown：按下键盘时触发<br>keypress：按下有值的键时触发，即按下 Ctrl、Alt、Shift 等这样无值的键，这个事件不会触发<br>keyup：松开键盘时触发该事件</p>
<p>KeyboardEvent 接口用来描述用户与键盘的互动。这个接口继承了 Event 接口，并且定义了自己的实例和方法。相关接口方法使用时查阅相关文档。</p>
<p>进度事件</p>
<p>进度事件用来描述资源的加载进度，主要由 AJAX 请求、<img>、<audio>、<video>、<style>、<link>等外部资源加载触发，继承了 ProgressEvent 接口。主要有以下几种事件：</p>
<p>abort：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件<br>error：由于错误导致外部资源无法加载时触发<br>load：外部资源加载成功时触发<br>loadstart：外部资源开始加载时触发<br>loadend：外部资源停止加载时触发<br>progress：外部资源加载过程中不断触发<br>timeout：加载超时时触发</p>
<p>ProgressEvent 接口主要用来描述外部资源加载的进度，比如 AJAX 加载、<img>、<video>、<style>、<link>等外部资源加载。进度相关的事件都继承了这个接口。</p>
<p>表单事件</p>
<p>input 事件：当 <input>、<select>、<textarea> 的值发生变化时触发。特点是连续触发，用户每按下一次按键，就会触发一次 input 事件。input 事件和 change 事件很像，不同之处在于 input 事件在元素的值发生变化后立即发生，而 change 在元素失去焦点时发生，而此内容可能已经发生多次变化<br>select 事件：select 事件当在 <input>、<textarea>里面选中文本时触发<br>change事件：当 <input>、<select>、<textarea> 的值发生变化时触发<br>submit事件：该事件发生在表单对象 <form> 上，而不是发生在表单成员上；submit 事件当表单数据向服务器提交时触发</p>
<p>InputEvent 接口主要用来描述 input 事件的实例。该接口继承了 Event 接口，还定义了一些自己的实例属性和实例方法。</p>
<p>触摸事件</p>
<p>触摸引发的事件，有以下几种：</p>
<p>touchstart：用户刚开始触摸时触发、它的 target 属性返回发生触摸的元素节点<br>touchend：用户不再接触触摸屏时（或者移除屏幕边缘）触发，它的 target 属性与 touchstart 事件一致的，就是开始触摸时所在的元素节点。<br>touchmove：用户移动触摸点时触发，它的target属性与touchstart事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件<br>touchcancel：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）</p>
<p>其它事件</p>
<p>load 事件在页面或某个资源加载成功时触发。注意，页面或资源从浏览器缓存加载，并不会触发 load 事件<br>postate 事件会在浏览器的 history 对象的当前记录发生显示切换（指鼠标点击“后退/前进”等操作，不包含调用 history.pushState 或者 history.replaceState 方法）时触发。<br>hashchange 事件在 URL 的 hash 部分（即#号后面的部分，包括#号）发生变化时触发。该事件一般在 window 对象上监听<br>readystatechange：当 Document 对象和 XMLHttpRequest 对象的 readyState 属性发生变化时触发<br>scroll：在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。会连续地大量触发，所以它的监听函数之中不应该有非常耗费计算的操作。推荐的做法是使用requestAnimationFrame或setTimeout控制该事件的触发频率，然后可以结合customEvent抛出一个新事件。<br>resize：在改变浏览器窗口大小时触发，主要发生在window对象上面<br>focus：元素节点获得焦点后触发，该事件不会冒泡<br>blur：元素节点失去焦点后触发，该事件不会冒泡</p>
<h1 id="JavaScript-环境概述"><a href="#JavaScript-环境概述" class="headerlink" title="JavaScript 环境概述"></a>JavaScript 环境概述</h1><p>JavaScript 是浏览器的内置脚本语言。浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。</p>
<h2 id="JavaScript-代码嵌入网页的方法"><a href="#JavaScript-代码嵌入网页的方法" class="headerlink" title="JavaScript 代码嵌入网页的方法"></a>JavaScript 代码嵌入网页的方法</h2><ul>
<li><code>&lt;script&gt;</code> 元素直接嵌入代码</li>
<li><code>&lt;script&gt;</code> 标签加载外部脚本</li>
<li>事件属性</li>
<li>URL 协议</li>
</ul>
<h2 id="script-工作原理"><a href="#script-工作原理" class="headerlink" title="script 工作原理"></a>script 工作原理</h2><p>浏览器加载 JavaScript 脚本，主要通过 <code>&lt;script&gt;</code> 元素完成。正常的网页加载流程是这样的：</p>
<ol>
<li>==浏览器一边下载 <code>HTML</code> 网页，一边开始解析。也就是说，不等到下载完，就开始解析。==</li>
<li>==解析过程中，浏览器发现 <code>&lt;script&gt;</code> 元素，就暂停解析，把网页渲染的控制权交给 JavaScript 引擎。==</li>
<li>==如果 <code>&lt;script&gt;</code> 元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。==</li>
<li>==JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 <code>HTML</code> 网页。==</li>
</ol>
<p>==加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 JavaScript 代码可以修改 DOM ，所以必须把控制权让给它，否则会导致负责的线程竞赛的问题。==</p>
<p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>
<p>为避免这种情况可以通过几种方案改善：</p>
<ul>
<li>将 <code>&lt;script&gt;</code> 标签都放在页面底部，而不是头部</li>
<li>设定 <code>DOMContentLoaded</code> 事件的回调函数</li>
<li>使用 <code>&lt;script&gt;</code> 标签的 <code>onload</code> 属性</li>
</ul>
<p>如果有多个 script 标签，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器会同时并行下载 <code>a.js</code> 和 <code>b.js</code> ，但是，==执行时会保证先执行 <code>a.js</code> ，然后再执行 <code>b.js</code> ，即使后者先下载完成，也是如此。脚本的执行顺序是由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不会受到破坏。==</p>
<p>对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载 6～20 个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大的压力。如果是来自不同域名的资源，就没有这个限制。所以，==通常把静态文件放在不同的域名之下，以加快下载速度。==</p>
<h2 id="defer-属性"><a href="#defer-属性" class="headerlink" title="defer 属性"></a>defer 属性</h2><p>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对 <code>&lt;script&gt;</code> 元素加入 <code>defer</code> 属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码，只有等 DOM 加载完成后，才会执行 <code>a.js</code> 和 <code>b.js</code>。</p>
<p><code>defer</code> 属性的运行流程：</p>
<ol>
<li>浏览器开始解析 <code>HTML</code> 网页</li>
<li>解析过程中，发现带有 <code>defer</code> 属性的 <code>&lt;script&gt;</code> 元素</li>
<li>浏览器继续往下解析 <code>HTML</code> 网页，同时并行下载 <code>&lt;script&gt;</code> 元素加载外部脚本</li>
<li>浏览器完成解析 <code>HTML</code> 网页，此时再回过头执行已经下载完成的脚本</li>
</ol>
<p>==对于内置而不是加载外部脚本的 <code>script</code> 标签，以及动态生成的 <code>script</code> 标签，<code>defer</code> 属性不起作用。==</p>
<h2 id="async-属性"><a href="#async-属性" class="headerlink" title="async 属性"></a>async 属性</h2><p>解决“阻塞效应”的另一个方法是对 <code>&lt;script&gt;</code> 元素加入 <code>async</code> 属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>async</code> 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p>
<ol>
<li>浏览器解析开始解析 HTML 网页</li>
<li>解析过程中，发现带有 async 属性的 script 标签</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载 <script> 标签中的外部脚本</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页</li>
</ol>
<p><code>async</code> 属性可以保证脚本下载的同时，浏览器继续渲染。要注意，==一旦采用这个属性，就无法保证脚本的执行顺序，哪个脚本先下载结束，就先执行哪个脚本。==</p>
<p>==一般来说，如果脚本之间没有依赖关系，就使用 async 属性，如果脚本之间有依赖关系，就用 defer 属性。如果同时使用 async 和 defer 属性，后者不起作用。==</p>
<h2 id="脚本的动态加载"><a href="#脚本的动态加载" class="headerlink" title="脚本的动态加载"></a>脚本的动态加载</h2><p><code>&lt;script&gt;</code> 元素还可以动态生成，生成后插入页面，从而实现脚本的动态加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a.js'</span>,<span class="string">'b.js'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种方式好处是，==动态生成的 script 标签不会阻塞页面渲染，也不会造成浏览器假死。== 但问题在于，这种方式无法保证脚本执行顺序，哪个脚本先下载完就先执行哪个。如果想避免这个问题，可以设置 <code>async</code> 属性为 <code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a.js'</span>, <span class="string">'b.js'</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.src = src;</span><br><span class="line">  script.async = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="加载使用的协议"><a href="#加载使用的协议" class="headerlink" title="加载使用的协议"></a>加载使用的协议</h2><p>如果不指定协议，浏览器默认采用 HTTP 协议下载。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果要采用 HTTPS 协议下载，必须写明。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想根据页面本身的协议来决定加载协议，可以这样。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//example.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h1><p>浏览器的核心是两部分：==渲染引擎和 JavaScript 解释器（JavaScript 引擎）。==</p>
<h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>==渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。==</p>
<p>不同浏览器有不同的渲染引擎：</p>
<ul>
<li>Firefox：<code>Gecko</code> 引擎</li>
<li>Safari：<code>WebKit</code> 引擎</li>
<li>Chrome：<code>Blink</code> 引擎</li>
<li>IE：<code>Trident</code> 引擎</li>
<li>Edge：<code>EdgeHTML</code> 引擎</li>
</ul>
<p>渲染引擎处理网页，通常分为四个阶段：</p>
<ol>
<li>解析代码：<code>HTML</code> 代码解析为 <code>DOM</code>，<code>CSS</code> 代码解析为 <code>CSSOM</code></li>
<li>对像合成：将 <code>DOM</code> 和 <code>CSSOM</code> 合成一棵渲染树</li>
<li>布局：计算出渲染树的布局</li>
<li>绘制：将渲染树绘制到屏幕</li>
</ol>
<p>以上四步并非严格按照顺序执行，往往第一步还没完成，第二步和第三步就开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完成，但浏览器已经显示出内容了。</p>
<h2 id="重流和重绘"><a href="#重流和重绘" class="headerlink" title="重流和重绘"></a>重流和重绘</h2><p>==渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。==</p>
<p>==页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停效果、页面滚动、在输入框中输入文本、改变窗口大小等。==</p>
<p>==重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。==</p>
<p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p>
<p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，==尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替。==</p>
<p>下面是一些优化技巧：</p>
<ul>
<li>读取 <code>DOM</code> 或者写入 <code>DOM</code>，尽量写在一起，不要混杂。不要读取一个 <code>DOM</code> 节点，然后立刻写入，接着再读取一个 <code>DOM</code> 节点</li>
<li>缓存 <code>DOM</code> 信息</li>
<li>不要一项一项地改变样式，而是使用 <code>CSS class</code> 一次性改变样式</li>
<li>使用 <code>documentFragment</code> 操作 <code>DOM</code></li>
<li>动画使用 <code>absolute</code> 定位或 <code>fixed</code> 定位，这样可以减少对其它元素的影响</li>
<li>只在必要时才显示隐藏元素</li>
<li>使用 <code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流</li>
<li>使用虚拟 DOM （<code>virtual DOM</code>）库</li>
</ul>
<h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>JavaScript 引擎的主要作用是，==读取网页中的 JavaScript 代码，对其处理后运行。==</p>
<p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都需要解释器，系统开销比较大，运行速度慢于编译型语言。</p>
<hr>
<h1 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h1><p>浏览器里面，<code>window</code> 对象（w为小写）指的是当前浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其它对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。<code>window</code> 有自己的实体含义，不适合作为最高一层的顶层对象，这是 JavaScript 语言设计的失误。</p>
<p>window 属性和方法不再列，常用的不多，需要时查询文档。</p>
<hr>
<h1 id="Navigator-对象，Screen-对象"><a href="#Navigator-对象，Screen-对象" class="headerlink" title="Navigator 对象，Screen 对象"></a>Navigator 对象，Screen 对象</h1><p><code>window.navigator</code> 属性指向一个包含浏览器和系统信息的 <code>Navigator</code> 对象。脚本通过这个属性了解用户环境信息。</p>
<p><code>navigator.userAgent</code> 属性返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.userAgent   <span class="comment">// "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.57 Safari/537.36"</span></span><br></pre></td></tr></table></figure>

<p><code>Screen</code> 对象表示当前窗口所在的屏幕，提供显示设备的信息。<code>window.screen</code> 属性指向这个对象。</p>
<hr>
<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>==Cookie 是服务器保存在浏览器的一小段文本信息，一般大小不能超过 4KB。浏览器每次向服务器发出请求，会自动附上这段信息。==</p>
<p>Cookie 主要作用：</p>
<ul>
<li>对话（session）管理：保存登陆、购物车等需要记录的信息</li>
<li>个性化信息：保存用户偏好，比如网页字体大小，背景色等</li>
<li>追踪用户：记录和分析用户行为</li>
</ul>
<p>==Cookie 不是一种理想的客户端存储机制。其容量很小，缺乏数据操作接口，而且会影响性能。客户端存储应该使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。==</p>
<p>每个 Cookie 都有以下几个方面的元数据：</p>
<ul>
<li>Cookie 的名字</li>
<li>Cookie 的值（真正的数据写在这里面）</li>
<li>到期时间（超过这个时间会失效）</li>
<li>所属域名（默认为当前域名）</li>
<li>生效的路径（默认为当前网址）</li>
</ul>
<h2 id="Cookie-与-HTTP-协议"><a href="#Cookie-与-HTTP-协议" class="headerlink" title="Cookie 与 HTTP 协议"></a>Cookie 与 HTTP 协议</h2><p>==Cookie 由 HTTP 协议生成，也主要是提供 HTTP 协议使用。==</p>
<p>服务器如果希望在浏览器保存 Cookie ，就要在 HTTP 回应的头信息里面，放置一个 Set-Cookie 字段。HTTP 回应可以包含多个 Set-Cookie 字段，即在浏览器生成多个 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 ok</span><br><span class="line">Content-type:text&#x2F;html</span><br><span class="line">Set-Cookie:yummy_cookie&#x3D;choco</span><br><span class="line">Set-Cookie:tasty_cookie&#x3D;strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>==如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的 key、domain、path、和 secure 都匹配。==</p>
<p>浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie 。服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。</p>
<p>Cookie 的各种属性，比如何时过期<br>哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的</p>
<h2 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h2><h3 id="Expires，Max-Age"><a href="#Expires，Max-Age" class="headerlink" title="Expires，Max-Age"></a>Expires，Max-Age</h3><p>Expires 属性指定一个具体的到期时间，到了指定时间后，浏览器就不再保留这个 Cookie。它的格式是 UTC 格式。如果不设置该属性，或者设置为 null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie:id=<span class="number">123</span>jjksdf; Expires=Wed, <span class="number">21</span> Oct <span class="number">2015</span> <span class="number">07</span>:<span class="number">22</span>:<span class="number">00</span> GMT;</span><br></pre></td></tr></table></figure>

<h3 id="Domain，Path"><a href="#Domain，Path" class="headerlink" title="Domain，Path"></a>Domain，Path</h3><p>Domain 属性指定浏览器发出 HTTP 请求时，哪些域名要附带上这个 Cookie。如果没有设定该属性，浏览器会默认将其设为当前域名，这时子域名将不会附带这个 Cookie。</p>
<h3 id="Secure，HttpOnly"><a href="#Secure，HttpOnly" class="headerlink" title="Secure，HttpOnly"></a>Secure，HttpOnly</h3><p>Secure 属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP ，浏览器会自动忽略服务器发来的 Secure 属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。</p>
<p>HttpOnly 属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是 document.cookie 属性、XMLHttpRequest 对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p>
<h3 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h3><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个 SameSite 属性，用来防止 CSRF 攻击和用户追踪。</p>
<h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p>document.cookie 属性用于读写当前网页的 Cookie。</p>
<p>读取的时候，它会返回当前网页所有 Cookie，前提是该 Cookie 不能有 HTTPOnly 属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie <span class="comment">// "foo=bar;baz=bar"</span></span><br></pre></td></tr></table></figure>

<p>document.cookie 属性是可写的，可以通过它为当前网站添加 Cookie。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'fontSize=14'</span>;</span><br></pre></td></tr></table></figure>

<p>写入的时候，Cookie 的值必须写为 key=value 的形式。注意，等号两边都不能有空格。</p>
<p>document.cookie 一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。同一个 Cookie 可以一次多写入属性。</p>
<p>各属性的写入注意点：</p>
<ul>
<li>path 属性必须为绝对路径，默认为当前路径</li>
<li>domain 属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是 example.com ，就不能将其设为 foo.com。该属性默认为当前的一级域名（不包含二级域名）</li>
<li>max-age 属性的值为秒数</li>
<li>expires 属性的值为 UTC 格式</li>
</ul>
<p>document.cookie 写入 Cookie 的例子如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'fontSize=14;'</span></span><br><span class="line">    + <span class="string">'expires='</span> + someDate.toGMTString() + <span class="string">';'</span></span><br><span class="line">    + <span class="string">'path=/subdirecotry;'</span></span><br><span class="line">    + <span class="string">'domain=*.example.com'</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="XMLHttpRequst-对象"><a href="#XMLHttpRequst-对象" class="headerlink" title="XMLHttpRequst 对象"></a>XMLHttpRequst 对象</h1><p>浏览器与服务器之间，采用 HTTP 协议通信。用户在浏览器地址输入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会向服务器发出 HTTP 请求。</p>
<p>==AJAX 指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要脚本发起通信，就可以叫 AJAX 通信。==</p>
<p>AJAX 包括以下几个步骤：</p>
<ol>
<li>创建 <code>XMLHttpRequest</code> 实例</li>
<li>发出 HTTP 请求</li>
<li>接收服务器传回的数据</li>
<li>更新网页数据</li>
</ol>
<p><code>XMLHttpRequest</code> 对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错。</p>
<p><code>XMLHttpRequest</code> 对象简单完整例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 通信成功时，状态值为4</span></span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status === <span class="number">200</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.statusText);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'/endpoint'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>

<h2 id="XMLHttpRequest-的实例属性"><a href="#XMLHttpRequest-的实例属性" class="headerlink" title="XMLHttpRequest 的实例属性"></a>XMLHttpRequest 的实例属性</h2><h3 id="XMLHttpRequest-readyState"><a href="#XMLHttpRequest-readyState" class="headerlink" title="XMLHttpRequest.readyState"></a>XMLHttpRequest.readyState</h3><p><code>XMLHttpRequest.readyState</code> 返回一个整数，表示实例对象当前的状态。该属性只读。可以返回很多值（<code>0、1、2、3、4</code>），==最重要的是状态值 <code>4</code> ，表示服务器返回的数据已经完全接收，或者本次接收已经失败。==</p>
<p>通信过程中，每当实例对象发生状态变化，它的 <code>readyState</code> 属性的值就会改变。这个值每一次变化，都会触发 <code>readyStateChange</code> 事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="comment">// 请求结束，处理服务器返回的数据</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 显示提示“加载中...”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-onreadystatechange"><a href="#XMLHttpRequest-onreadystatechange" class="headerlink" title="XMLHttpRequest.onreadystatechange"></a>XMLHttpRequest.onreadystatechange</h3><p><code>XMLHttpRequest.onreadystatechange</code> 属性指向一个监听函数。</p>
<p><code>readystatechange</code> 事件发生时（实例的 <code>readyState</code> 属性变化），就会执行这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'GET'</span>,<span class="string">'http://example.com'</span>,<span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState !== <span class="number">4</span> || xhr.status !== <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-response"><a href="#XMLHttpRequest-response" class="headerlink" title="XMLHttpRequest.response"></a>XMLHttpRequest.response</h3><p><code>XMLHttpRequest.response</code> 属性表示服务器返回的数据体（即 HTTP 回应的 <code>body</code> 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体类型由 <code>XMLHttpRequest.responseType</code> 属性决定。该属性只读。</p>
<p>如果本次请求没有成功或者数据不完整，该属性等于 null 。但是，如果 <code>responseType</code> 属性等于 <code>text</code> 或空字符串，在请求没有结束之前（<code>readyState</code> 等于 <code>3</code> 的阶段），<code>response</code> 属性包含服务器已经返回的部分数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        handler(xhr.response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-responseType"><a href="#XMLHttpRequest-responseType" class="headerlink" title="XMLHttpRequest.responseType"></a>XMLHttpRequest.responseType</h3><p><code>XMLHttpRequest.responseType</code> 属性是一个字符串，表示服务器返回数据的类型。该属性可写，可以在调用 <code>open()</code> 方法后、调用 <code>send()</code> 方法前，设置该属性值，告诉服务器返回指定数据的类型。如果 <code>responseType</code> 设置为空字符串，等同于默认值 <code>text</code> 。</p>
<p><code>XMLHttpRequest.responseType</code> 属性可以等于以下值：</p>
<ul>
<li><code>&quot;&quot;</code>（空字符串）：等同于 <code>text</code>，表示服务器返回文本数据</li>
<li><code>&quot;arraybuffer&quot;</code>：<code>ArrayBuffer</code> 对象，表示服务器返回二进制数组</li>
<li><code>&quot;blob&quot;</code>：<code>Blob</code> 对象，表示服务器返回二进制对象</li>
<li><code>&quot;document&quot;</code>：<code>Document</code> 对象，表示服务器返回一个文档对象</li>
<li><code>&quot;json&quot;</code>：<code>JSON</code> 对象</li>
<li><code>&quot;text&quot;</code>：字符串</li>
</ul>
<p><code>text</code> 类型适合大多数情况，而且直接处理文本也比较方便。<code>document</code> 类型合适返回 <code>HTML/XML</code> 文档的情况，这意味着，对于那些打开 <code>CORS</code> 的网站，可以直接用 <code>Ajax</code> 抓取网页，直接对抓取回来的数据进行 <code>DOM</code> 操作。<code>blob</code> 类型适合读取二进制数据，比如图片文件。<code>ArrayBuffer</code> 是按照数组的方式处理二进制数据。如果设置为 json，浏览器就会自动返回数据调用 JSON.parse（）方法。也就是说，从 xhr.response 属性（注意，不是 xhr.responseText 属性）得到的不是文本，而是一个 JSON 对象。</p>
<h3 id="XMLHttpRequest-status，XMLHttpRequest-statusText"><a href="#XMLHttpRequest-status，XMLHttpRequest-statusText" class="headerlink" title="XMLHttpRequest.status，XMLHttpRequest.statusText"></a>XMLHttpRequest.status，XMLHttpRequest.statusText</h3><p><code>XMLHttpRequest.status</code> 属性返回一个整数，表示服务器回应的 HTTP 状态码。一般来说，如果通信成功的话，这个状态码是 <code>200</code>；如果服务器没有返回状态码，那么这个属性默认是 <code>200</code>。请求发出前，该属性为 <code>0</code>。</p>
<ul>
<li><code>200</code>，OK，访问正常</li>
<li><code>301</code>，永久移动</li>
<li><code>302</code>，暂时移动</li>
<li><code>304</code>，未修改</li>
<li><code>307</code>，暂时重定向</li>
<li><code>401</code>，未授权</li>
<li><code>403</code>，禁止访问</li>
<li><code>404</code>，未发现指定网址</li>
<li><code>500</code>，服务器发生错误</li>
</ul>
<p>==基本上，只有 <code>2xx</code> 和 <code>304</code> 的状态码，表示服务器返回时正常状态。==</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || (xhr.status === <span class="number">304</span>))&#123;</span><br><span class="line">        <span class="comment">// 处理服务器返回数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 出错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XMLHttpRequest.statusText</code> 属性返回一个字符串，表示服务器发送的状态提示。不同于 <code>status</code> 属性，该属性包含整个状态信息，比如 <code>“OK”</code> 和 <code>“Not Found”</code>。</p>
<h3 id="XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout"><a href="#XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout" class="headerlink" title="XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout"></a>XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout</h3><p><code>XMLHttpRequest.timeout</code>  属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于 <code>0</code> ，就表示没有时间限制。</p>
<p><code>XMLHttpRequestEventTarget.ontimeout</code> 属性设置一个监听函数，如果发生 <code>timeout</code> 事件，就会执行这个监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">var url &#x3D; &#39;&#x2F;server&#39;;</span><br><span class="line"></span><br><span class="line">xhr.ontimeout &#x3D; function()&#123;</span><br><span class="line">    console.err(&#39;The request for&#39; + url + &#39;timed out.&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.onload &#x3D; function()&#123;</span><br><span class="line">    if(xhr.readyState &#x3D;&#x3D;&#x3D; 4)&#123;</span><br><span class="line">        if(xhr.status &#x3D;&#x3D;&#x3D; 200)&#123;</span><br><span class="line">            &#x2F;&#x2F;处理服务器返回的数据</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.err(xhr.statusText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(&#39;GET&#39;,url,true);</span><br><span class="line">&#x2F;&#x2F;指定 10 秒超时</span><br><span class="line">xhr.timeout &#x3D; 10*1000;</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<h2 id="事件监听属性"><a href="#事件监听属性" class="headerlink" title="事件监听属性"></a>事件监听属性</h2><p>XMLHttpRequest 对象可以对以下事件指定监听函数：</p>
<ul>
<li>XMLHttpRequest.onloadstart：loadstart 事件（HTTP 请求发出）的监听函数</li>
<li>XMLHttpRequest.onprogress：progress事件（正在发送和加载数据）的监听函数</li>
<li>XMLHttpRequest.onabort：abort 事件（请求中止，比如用户调用了abort()方法）的监听函数</li>
<li>XMLHttpRequest.onerror：error 事件（请求失败）的监听函数</li>
<li>XMLHttpRequest.onload：load 事件（请求成功完成）的监听函数</li>
<li>XMLHttpRequest.ontimeout：timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数</li>
<li>XMLHttpRequest.onloadend：loadend 事件（请求完成，不管成功或失败）的监听函数</li>
</ul>
<h3 id="XMLHttpRequest-withCredentials"><a href="#XMLHttpRequest-withCredentials" class="headerlink" title="XMLHttpRequest.withCredentials"></a>XMLHttpRequest.withCredentials</h3><p>XMLHttpRequest.withCredentials 属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为 false，即向 example.com 发出跨域请求时，不会发送 example.com 设置在本机上的 Cookie（如果有的话）。详细用法，略。</p>
<h3 id="XMLHttpRequest-upload"><a href="#XMLHttpRequest-upload" class="headerlink" title="XMLHttpRequest.upload"></a>XMLHttpRequest.upload</h3><p>XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。</p>
<p>XMLHttpRequest 的实例方法</p>
<p>XMLHttpRequest.open（）</p>
<p>XMLHttpRequest.open（）方法可以用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受 5 个参数。</p>
<p>void open (<br>    string method,<br>    string url,<br>    optional boolean async,<br>    optional string user,<br>    optional string password<br>    );</p>
<p>method：表示 HTTP 动词方法，比如 GET、POST、PUT、HEAD等<br>ulr：表示请求发送目标 URL<br>async：布尔值，表示请求是否为异步，默认为 true（异步），同步的情况不常用<br>user：表示用于认证的用户名，默认空字符串，该参数可选<br>password：用于认证的密码，默认为空字符串，该参数可选</p>
<p>如果使用过 open（）方法的 AJAX 请求，再次使用这个方法，等同于调用 abort（），即终止请求。</p>
<p>var xhr = new XMLHttpRequest();<br>xhr.open('POST',encodeURI('someURL'));</p>
<p>XMLHttpRequest.send（）</p>
<p>XMLHttpRequest.send（）方法用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL ，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示出了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。</p>
<p>GET 请求：<br>var xhr = new XMLHttpRequest();</p>
<p>xhr.open('GET','<a href="http://www.xxx.com/?id=123&#39;,true" target="_blank" rel="noopener">http://www.xxx.com/?id=123&#39;,true</a>)</p>
<p>xhr.send(null);</p>
<p>POST 请求：<br>var xhr = new XMLHttpRequest();</p>
<p>var data = 'email='</p>
<ul>
<li>encodeURIComponent(email)</li>
<li>'&password='</li>
<li>encodeURIComponent(password);</li>
</ul>
<p>xhr.open('POST','<a href="http://www.xxx.com/&#39;,true" target="_blank" rel="noopener">http://www.xxx.com/&#39;,true</a>);<br>xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');<br>xhr.send(data);</p>
<p>注意，所有 XMLHttpRequest 的监听事件，都必须在 send（）方法调用前设定。</p>
<p>send 方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。</p>
<p>XMLHttpRequest.setRequestHeader（）</p>
<p>XMLHttpRequest.setRequestHeader（）方法用于设置浏览器发送的 HTTP 请求头信息。</p>
<p>XMLHttpRequest 实例的事件</p>
<p>readyStateChange 事件</p>
<p>readyState 属性的值发生改变，就会触发 readyStateChange 事件。</p>
<p>progress 事件</p>
<p>上传文件时，会不断返回上传的进度。</p>
<hr>
<h1 id="同源限制"><a href="#同源限制" class="headerlink" title="同源限制"></a>同源限制</h1><p>浏览器安全的基石是“同源政策”。==所谓“同源”是指协议相同、域名相同、端口相同。同源政策的目的，是为了保证用户信息安全，防止恶意网站窃取数据。==</p>
<h2 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h2><p>目前，如果非同源，共有三种行为受到限制：</p>
<ul>
<li>无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB</li>
<li>无法接触非同源网页的 DOM</li>
<li>无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒接接受响应）</li>
</ul>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也会受到影响。</p>
<p>下面介绍如何规避上面的限制。</p>
<h2 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。如果两个网页一级域名相同，只是次域名不同，浏览器允许通过设置 document.domain 共享 Cookie。</p>
<p>举例来说，A 网页的网址是 <code>http://w1.example.com/a.html</code>，B 网页的网址是 <code>http://w2.example.com/b.html</code>，那么只要设置相同的 document.domain，两个网页就可以共享 Cookie。因为浏览器通过 <code>document.domain</code> 属性来检查是否同源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个网页都需要设置</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'example.com'</span>;</span><br></pre></td></tr></table></figure>

<p>注意，A 和 B 两个网页都需要设置 <code>document.domain</code> 属性，才能达到同源的目的。</p>
<p>现在，A 网页通过脚本设置一个 Cookie。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'test1=hello'</span>;</span><br></pre></td></tr></table></figure>

<p>B 网页就可以读取到这个 Cookie。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allCookie = <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure>

<p>这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法使用。</p>
<p>服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如 .example.com。这样的话，二级域名、三级域名不做任何设置，都可以读取这个 Cookie。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:key=value;domain=.example.com;path=/</span><br></pre></td></tr></table></figure>

<h2 id="iframe-和多窗口通信"><a href="#iframe-和多窗口通信" class="headerlink" title="iframe 和多窗口通信"></a>iframe 和多窗口通信</h2><p>iframe 元素可以在当前网页中，嵌入其他网页。每个 iframe 元素形成自己的窗口，即有自己的 window 对象。iframe 窗口中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。</p>
<p>对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题：片段识别符、跨文档通信 API。</p>
<h3 id="片段识别符"><a href="#片段识别符" class="headerlink" title="片段识别符"></a>片段识别符</h3><p>片段识别符指的是，URL 的 # 号后面的部分，比如 <code>http://example.com/x.html#fragment</code> 的 <code>#frament</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> src = originURL + <span class="string">'#'</span> + data;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'myFrame'</span>).src = src;</span><br></pre></td></tr></table></figure>

<p>子窗口通过监听 hashchange 事件得到通知。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = checkMessage;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMessage</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">window</span>.location.hash;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，子窗口也可以改变父窗口的片段标识符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.location.href = target + <span class="string">'#'</span> + hash;</span><br></pre></td></tr></table></figure>

<h3 id="window-postMessage（）"><a href="#window-postMessage（）" class="headerlink" title="window.postMessage（）"></a>window.postMessage（）</h3><p>HTML5 引入了一个全新的 API：跨文档通信 API。</p>
<p>这个 API 为 window 对象新增了一个 <code>window.postMessage</code> 方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>例如，父窗口 <code>aaa.com</code> 向子窗口 <code>bbb.com</code> 发消息，调用 <code>postMessage</code> 方法就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口打开一个子窗口</span></span><br><span class="line"><span class="keyword">var</span> popup = <span class="built_in">window</span>.open(<span class="string">'http://bbb.com'</span>,<span class="string">'title'</span>);</span><br><span class="line"><span class="comment">// 父窗口向子窗口发消息</span></span><br><span class="line">popup.postMessage(<span class="string">'Hello world'</span>,<span class="string">'http://bbb.com'</span>)</span><br></pre></td></tr></table></figure>

<p><code>postMessage</code> 方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源，即 <code>“协议+域名+端口”</code>。也可以设为 <code>*</code> ，表示不限制域名，向所有窗口发送（不推荐，不够安全，可能会被恶意利用）。</p>
<p>子组件向父窗口发送消息的写法类似。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子窗口向父窗口发消息</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(<span class="string">'Nice to see you'</span>,<span class="string">'http://aaa.com'</span>)</span><br></pre></td></tr></table></figure>

<p>父子窗口都可以通过 message 事件，监听对方消息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><p>通过 <code>window.postMessage</code>，读写其他窗口的 <code>LocalStorage</code> 也成为了可能。详细用法略。</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>同源政策规定，AJAX 请求只能发送给同源的网址，否则就会报错。</p>
<p>==除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制：JSONP、WebSocket、CORS。==</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP 是服务器与客户端夸源通信的常用方法。最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。</p>
<p>步骤如下：</p>
<p>1、网页添加一个 <script> 元素，向服务器请求一个脚本，不受同源政策限制，可以跨域请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://api.foo.com?callback=bar"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，请求的脚本网址有一个 callback 参数（?callback=bar），用来告诉服务器，客户端的回调函数名称（bar）。</p>
<p>2、服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数里面，作为字符串返回（<code>bar（{...}）</code>）。</p>
<p>3、客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是 <code>&lt;script&gt;</code> 标签请求的脚本内容。这时，客户端只要定义了 <code>bar()</code> 函数，就能在该函数体内，拿到服务器返回的 JSON 数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.setAttribute(<span class="string">'type'</span>,<span class="string">'text/javascript'</span>);</span><br><span class="line">    script.src = src;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    addScriptTag(<span class="string">'http://example.com/ip?callback=foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Your public IP address is:'</span> + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p><code>WebSocket</code> 是一种通信协议，使用 <code>ws://</code> （非加密）和 <code>wss://</code> （加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><code>CORS</code> 是跨域资源共享。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发 GET 请求，CORS 允许任何类型的请求。</p>
<hr>
<h1 id="CORS-通信"><a href="#CORS-通信" class="headerlink" title="CORS 通信"></a>CORS 通信</h1><p>CORS 是一个 W3C 标准，全称是“跨域资源共享”。它允许浏览器向跨域的服务器，发出 <code>XMLHttpRequest</code> 请求，从而克服了 AJAX 只能同源使用的限制。</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有的浏览器都支持该功能。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加头的头信息，有时还会多出一次附加请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p>
<h2 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h2><p>CORS 请求分成两类：简单请求和非简单请求。</p>
<p>只要满足以下两大条件，就属于简单请求。</p>
<p>（1）请求方法是以下三种方法之一。</p>
<p>HEAD<br>GET<br>POST</p>
<p>（2）HTTP 的头信息不超出以下几种字段</p>
<p>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</p>
<p>凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法 与简单的 HTTP 头信息的结合。</p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>基本流程</p>
<p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。</p>
<p>下面是个例子，浏览器发现这次跨域 AJAX 请求就是简单请求，就自动在头信息之中，添加一个 Origin 字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></figure>


      </div>
      
      
      
    </div>
    

    
    
    


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本语法"><span class="nav-number">1.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#语句"><span class="nav-number">1.1.</span> <span class="nav-text">语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">1.2.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量提升"><span class="nav-number">1.2.2.</span> <span class="nav-text">变量提升</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标识符"><span class="nav-number">1.3.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注释"><span class="nav-number">1.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区块"><span class="nav-number">1.5.</span> <span class="nav-text">区块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条件语句"><span class="nav-number">1.6.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if-结构"><span class="nav-number">1.6.1.</span> <span class="nav-text">if 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#if-…-else-结构"><span class="nav-number">1.6.2.</span> <span class="nav-text">if … else 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-结构"><span class="nav-number">1.6.3.</span> <span class="nav-text">switch 结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三元运算符"><span class="nav-number">1.6.4.</span> <span class="nav-text">三元运算符 ? :</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环语句"><span class="nav-number">1.7.</span> <span class="nav-text">循环语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#while-循环"><span class="nav-number">1.7.1.</span> <span class="nav-text">while 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-循环"><span class="nav-number">1.7.2.</span> <span class="nav-text">for 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-…-while-循环"><span class="nav-number">1.7.3.</span> <span class="nav-text">do … while 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#break-语句和-continue-语句"><span class="nav-number">1.7.4.</span> <span class="nav-text">break 语句和 continue 语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据分类"><span class="nav-number">2.1.</span> <span class="nav-text">数据分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typeof-运算符"><span class="nav-number">2.2.</span> <span class="nav-text">typeof 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#null-undefined-和布尔值"><span class="nav-number">2.3.</span> <span class="nav-text">null, undefined 和布尔值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#null-和-undefined"><span class="nav-number">2.3.1.</span> <span class="nav-text">null 和 undefined</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔值"><span class="nav-number">2.3.2.</span> <span class="nav-text">布尔值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值"><span class="nav-number">2.4.</span> <span class="nav-text">数值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NaN"><span class="nav-number">2.4.1.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parseInt"><span class="nav-number">2.4.2.</span> <span class="nav-text">parseInt()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parseFloat"><span class="nav-number">2.4.3.</span> <span class="nav-text">parseFloat()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isNaN"><span class="nav-number">2.4.4.</span> <span class="nav-text">isNaN()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">2.5.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#转义"><span class="nav-number">2.5.1.</span> <span class="nav-text">转义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串与数组"><span class="nav-number">2.5.2.</span> <span class="nav-text">字符串与数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#length-属性"><span class="nav-number">2.5.3.</span> <span class="nav-text">length 属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象"><span class="nav-number">2.6.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#键名"><span class="nav-number">2.6.1.</span> <span class="nav-text">键名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的引用"><span class="nav-number">2.6.2.</span> <span class="nav-text">对象的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表达式还是语句？"><span class="nav-number">2.6.3.</span> <span class="nav-text">表达式还是语句？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性操作"><span class="nav-number">2.6.4.</span> <span class="nav-text">属性操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#属性读取"><span class="nav-number">2.6.4.1.</span> <span class="nav-text">属性读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性赋值"><span class="nav-number">2.6.4.2.</span> <span class="nav-text">属性赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性的查看"><span class="nav-number">2.6.4.3.</span> <span class="nav-text">属性的查看</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性的删除：delete-命令"><span class="nav-number">2.6.4.4.</span> <span class="nav-text">属性的删除：delete 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性是否存在：in-运算符"><span class="nav-number">2.6.4.5.</span> <span class="nav-text">属性是否存在：in 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性的遍历：for…in-循环"><span class="nav-number">2.6.4.6.</span> <span class="nav-text">属性的遍历：for…in 循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">2.7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的声明"><span class="nav-number">2.7.1.</span> <span class="nav-text">函数的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#圆括号运算符，return-语句"><span class="nav-number">2.7.2.</span> <span class="nav-text">圆括号运算符，return 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归"><span class="nav-number">2.7.3.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数名的提升"><span class="nav-number">2.7.4.</span> <span class="nav-text">函数名的提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的属性和方法"><span class="nav-number">2.7.5.</span> <span class="nav-text">函数的属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#name"><span class="nav-number">2.7.5.1.</span> <span class="nav-text">name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#length-属性-1"><span class="nav-number">2.7.5.2.</span> <span class="nav-text">length 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#toString-NaN"><span class="nav-number">2.7.5.3.</span> <span class="nav-text">toString()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数作用域"><span class="nav-number">2.7.6.</span> <span class="nav-text">函数作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义"><span class="nav-number">2.7.6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数内部的变量提升"><span class="nav-number">2.7.6.2.</span> <span class="nav-text">函数内部的变量提升</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数本身的作用域"><span class="nav-number">2.7.6.3.</span> <span class="nav-text">函数本身的作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数"><span class="nav-number">2.7.7.</span> <span class="nav-text">参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述"><span class="nav-number">2.7.7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传递方式"><span class="nav-number">2.7.7.2.</span> <span class="nav-text">传递方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">2.7.8.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即调用的函数表达式（IIFE）"><span class="nav-number">2.7.9.</span> <span class="nav-text">立即调用的函数表达式（IIFE）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量的声明"><span class="nav-number">3.</span> <span class="nav-text">变量的声明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-5-1"><span class="nav-number">3.1.</span> <span class="nav-text">JavaScript 5.1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6"><span class="nav-number">3.2.</span> <span class="nav-text">ES6</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运算符"><span class="nav-number">4.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#取反运算符（-）"><span class="nav-number">4.1.</span> <span class="nav-text">取反运算符（!）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#或运算符（a-b）"><span class="nav-number">4.2.</span> <span class="nav-text">或运算符（a || b）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#且运算符（a-amp-amp-b）"><span class="nav-number">4.3.</span> <span class="nav-text">且运算符（a &amp;&amp; b）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#和"><span class="nav-number">4.4.</span> <span class="nav-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三元条件运算符（a-b-c）"><span class="nav-number">4.5.</span> <span class="nav-text">三元条件运算符（a ? b : c）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自增和自减"><span class="nav-number">4.6.</span> <span class="nav-text">自增和自减</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据类型转换"><span class="nav-number">5.</span> <span class="nav-text">数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#强制转换"><span class="nav-number">5.1.</span> <span class="nav-text">强制转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动转换"><span class="nav-number">5.2.</span> <span class="nav-text">自动转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动转换为布尔值"><span class="nav-number">5.2.1.</span> <span class="nav-text">自动转换为布尔值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动转换为字符串"><span class="nav-number">5.2.2.</span> <span class="nav-text">自动转换为字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自动转换为数值"><span class="nav-number">5.2.3.</span> <span class="nav-text">自动转换为数值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-常见用法"><span class="nav-number">6.</span> <span class="nav-text">String 常见用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prototype-slice"><span class="nav-number">6.1.</span> <span class="nav-text">String.prototype.slice()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prototype-substring-、String-prototype-substr"><span class="nav-number">6.2.</span> <span class="nav-text">String.prototype.substring()、String.prototype.substr()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prototype-indexOf-、String-prototype-lastIndexOf"><span class="nav-number">6.3.</span> <span class="nav-text">String.prototype.indexOf()、String.prototype.lastIndexOf()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prototype-trim"><span class="nav-number">6.4.</span> <span class="nav-text">String.prototype.trim()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prototype-toLowerCase-、toUpperCase"><span class="nav-number">6.5.</span> <span class="nav-text">String.prototype.toLowerCase()、toUpperCase()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prototype-match"><span class="nav-number">6.6.</span> <span class="nav-text">String.prototype.match()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prorotype-search"><span class="nav-number">6.7.</span> <span class="nav-text">String.prorotype.search()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prototype-replace"><span class="nav-number">6.8.</span> <span class="nav-text">String.prototype.replace()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-prototype-split"><span class="nav-number">6.9.</span> <span class="nav-text">String.prototype.split()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Number-常见用法"><span class="nav-number">7.</span> <span class="nav-text">Number 常见用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-prototype-toString"><span class="nav-number">7.1.</span> <span class="nav-text">Number.prototype.toString()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Number-prototype-toFiexd"><span class="nav-number">7.2.</span> <span class="nav-text">Number.prototype.toFiexd()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局方法-parseInt"><span class="nav-number">7.3.</span> <span class="nav-text">全局方法 parseInt()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局方法-parseFloat"><span class="nav-number">7.4.</span> <span class="nav-text">全局方法 parseFloat()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NaN、全局方法-isNaN"><span class="nav-number">7.5.</span> <span class="nav-text">NaN、全局方法 isNaN()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Array-常见用法"><span class="nav-number">8.</span> <span class="nav-text">Array 常见用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-isArray"><span class="nav-number">8.1.</span> <span class="nav-text">Array.isArray()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#push"><span class="nav-number">8.2.</span> <span class="nav-text">push()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pop"><span class="nav-number">8.3.</span> <span class="nav-text">pop()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shift"><span class="nav-number">8.4.</span> <span class="nav-text">shift()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unshift"><span class="nav-number">8.5.</span> <span class="nav-text">unshift()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join"><span class="nav-number">8.6.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concat"><span class="nav-number">8.7.</span> <span class="nav-text">concat()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slice"><span class="nav-number">8.8.</span> <span class="nav-text">slice()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#splice"><span class="nav-number">8.9.</span> <span class="nav-text">splice()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#indexOf-、lastIndexOf"><span class="nav-number">8.10.</span> <span class="nav-text">indexOf()、lastIndexOf()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map"><span class="nav-number">8.11.</span> <span class="nav-text">map()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#forEach"><span class="nav-number">8.12.</span> <span class="nav-text">forEach()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#filter"><span class="nav-number">8.13.</span> <span class="nav-text">filter()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in-运算符、for-…-in-循环"><span class="nav-number">8.14.</span> <span class="nav-text">in 运算符、for … in 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的遍历"><span class="nav-number">8.15.</span> <span class="nav-text">数组的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类数组对象"><span class="nav-number">8.16.</span> <span class="nav-text">类数组对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-常见用法"><span class="nav-number">9.</span> <span class="nav-text">Object 常见用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#delete-命令"><span class="nav-number">9.1.</span> <span class="nav-text">delete 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in-运算符"><span class="nav-number">9.2.</span> <span class="nav-text">in 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-…-in-循环"><span class="nav-number">9.3.</span> <span class="nav-text">for … in 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-keys-、Object-getOwnPropertyNames"><span class="nav-number">9.4.</span> <span class="nav-text">Object.keys()、Object.getOwnPropertyNames()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString-应用：判断数据类型"><span class="nav-number">9.5.</span> <span class="nav-text">toString()应用：判断数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-prototype-hasOwnProperty"><span class="nav-number">9.6.</span> <span class="nav-text">Object.prototype.hasOwnProperty()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Math-用法"><span class="nav-number">10.</span> <span class="nav-text">Math 用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-abs"><span class="nav-number">10.1.</span> <span class="nav-text">Math.abs()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-max-、Math-min"><span class="nav-number">10.2.</span> <span class="nav-text">Math.max()、Math.min()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-floor-、Math-ceil"><span class="nav-number">10.3.</span> <span class="nav-text">Math.floor()、Math.ceil()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-round"><span class="nav-number">10.4.</span> <span class="nav-text">Math.round()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Math-random"><span class="nav-number">10.5.</span> <span class="nav-text">Math.random()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Date-对象常见用法"><span class="nav-number">11.</span> <span class="nav-text">Date 对象常见用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Date"><span class="nav-number">11.1.</span> <span class="nav-text">Date()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date-now"><span class="nav-number">11.2.</span> <span class="nav-text">Date.now()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#get-类方法（set-）"><span class="nav-number">11.3.</span> <span class="nav-text">get 类方法（set*）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#getTime"><span class="nav-number">11.3.1.</span> <span class="nav-text">getTime()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getFullYear-、getMonth-、getDate-、getDay"><span class="nav-number">11.3.2.</span> <span class="nav-text">getFullYear()、getMonth()、getDate()、getDay()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getHours-、getMinutes-、getSeconds"><span class="nav-number">11.3.3.</span> <span class="nav-text">getHours()、getMinutes()、getSeconds()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Regexp-用法"><span class="nav-number">12.</span> <span class="nav-text">Regexp 用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSON-对象用法"><span class="nav-number">13.</span> <span class="nav-text">JSON 对象用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-stringify-、JSON-parse"><span class="nav-number">13.1.</span> <span class="nav-text">JSON.stringify()、JSON.parse()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#面向对象编程"><span class="nav-number">14.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数"><span class="nav-number">14.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-命令"><span class="nav-number">14.2.</span> <span class="nav-text">new 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-create-创建实例对象"><span class="nav-number">14.3.</span> <span class="nav-text">Object.create() 创建实例对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-关键字"><span class="nav-number">14.4.</span> <span class="nav-text">this 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定-this-的方法"><span class="nav-number">14.4.1.</span> <span class="nav-text">绑定 this 的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-prototype-call"><span class="nav-number">14.4.1.1.</span> <span class="nav-text">Function.prototype.call()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-prototype-apply"><span class="nav-number">14.4.1.2.</span> <span class="nav-text">Function.prototype.apply()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-prototype-bind"><span class="nav-number">14.4.1.3.</span> <span class="nav-text">Function.prototype.bind()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何选用"><span class="nav-number">14.4.2.</span> <span class="nav-text">如何选用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点总结"><span class="nav-number">14.4.3.</span> <span class="nav-text">特点总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数的缺点"><span class="nav-number">14.5.</span> <span class="nav-text">构造函数的缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prototype-属性的作用"><span class="nav-number">14.6.</span> <span class="nav-text">prototype 属性的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链"><span class="nav-number">14.7.</span> <span class="nav-text">原型链</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constructor-属性"><span class="nav-number">14.8.</span> <span class="nav-text">constructor 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#instanceof-运算符"><span class="nav-number">14.9.</span> <span class="nav-text">instanceof 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造函数继承"><span class="nav-number">14.10.</span> <span class="nav-text">构造函数继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多重继承"><span class="nav-number">14.11.</span> <span class="nav-text">多重继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块化"><span class="nav-number">14.12.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-对象的相关方法"><span class="nav-number">14.13.</span> <span class="nav-text">Object 对象的相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getPrototypeOf"><span class="nav-number">14.13.1.</span> <span class="nav-text">Object.getPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-setPrototypeOf"><span class="nav-number">14.13.2.</span> <span class="nav-text">Object.setPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-create"><span class="nav-number">14.13.3.</span> <span class="nav-text">Object.create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-isPrototypeOf"><span class="nav-number">14.13.4.</span> <span class="nav-text">Object.prototype.isPrototypeOf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-prototype-proto"><span class="nav-number">14.13.5.</span> <span class="nav-text">Object.prototype.__proto__</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取原型对象方法比较"><span class="nav-number">14.13.6.</span> <span class="nav-text">获取原型对象方法比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的拷贝"><span class="nav-number">14.14.</span> <span class="nav-text">对象的拷贝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定时器"><span class="nav-number">15.</span> <span class="nav-text">定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#setTimeout"><span class="nav-number">15.1.</span> <span class="nav-text">setTimeout()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setInterval"><span class="nav-number">15.2.</span> <span class="nav-text">setInterval()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clearTimeout-、clearInterval"><span class="nav-number">15.3.</span> <span class="nav-text">clearTimeout()、clearInterval()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DOM-概述"><span class="nav-number">16.</span> <span class="nav-text">DOM 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DOM"><span class="nav-number">16.1.</span> <span class="nav-text">DOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点"><span class="nav-number">16.2.</span> <span class="nav-text">节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#节点树"><span class="nav-number">16.3.</span> <span class="nav-text">节点树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-接口"><span class="nav-number">17.</span> <span class="nav-text">Node 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#属性"><span class="nav-number">17.1.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-nodeType"><span class="nav-number">17.1.1.</span> <span class="nav-text">Node.prototype.nodeType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-nodeName"><span class="nav-number">17.1.2.</span> <span class="nav-text">Node.prototype.nodeName</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-nodeValue"><span class="nav-number">17.1.3.</span> <span class="nav-text">Node.prototype.nodeValue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-prototype-textContent"><span class="nav-number">17.2.</span> <span class="nav-text">Node.prototype.textContent</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-baseURI"><span class="nav-number">17.2.1.</span> <span class="nav-text">Node.prototype.baseURI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-nextSibling"><span class="nav-number">17.2.2.</span> <span class="nav-text">Node.prototype.nextSibling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-previousSibling"><span class="nav-number">17.2.3.</span> <span class="nav-text">Node.prototype.previousSibling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-parentNode"><span class="nav-number">17.2.4.</span> <span class="nav-text">Node.prototype.parentNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-parentElement"><span class="nav-number">17.2.5.</span> <span class="nav-text">Node.prototype.parentElement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-firstChild、Node-prototype-lastChild"><span class="nav-number">17.2.6.</span> <span class="nav-text">Node.prototype.firstChild、Node.prototype.lastChild</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-childNodes"><span class="nav-number">17.2.7.</span> <span class="nav-text">Node.prototype.childNodes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-number">17.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-appendChild"><span class="nav-number">17.3.1.</span> <span class="nav-text">Node.prototype.appendChild()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-hasChildNodes"><span class="nav-number">17.3.2.</span> <span class="nav-text">Node.prototype.hasChildNodes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-cloneNode"><span class="nav-number">17.3.3.</span> <span class="nav-text">Node.prototype.cloneNode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-insertBefore"><span class="nav-number">17.3.4.</span> <span class="nav-text">Node.prototype.insertBefore()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-removeChild"><span class="nav-number">17.3.5.</span> <span class="nav-text">Node.prototype.removeChild()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-prototype-replaceChild"><span class="nav-number">17.3.6.</span> <span class="nav-text">Node.prototype.replaceChild()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NodeList接口、HTMLCollection-接口"><span class="nav-number">18.</span> <span class="nav-text">NodeList接口、HTMLCollection 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NodeList接口"><span class="nav-number">18.1.</span> <span class="nav-text">NodeList接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">18.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NodeList-prototype-length"><span class="nav-number">18.1.2.</span> <span class="nav-text">NodeList.prototype.length</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NodeList-prototype-forEach"><span class="nav-number">18.1.3.</span> <span class="nav-text">NodeList.prototype.forEach()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NodeList-prototype-item"><span class="nav-number">18.1.4.</span> <span class="nav-text">NodeList.prototype.item()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NodeList-prototype-keys-，NodeList-prototype-values-，NodeList-prototype-entries"><span class="nav-number">18.1.5.</span> <span class="nav-text">NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTMLCollection-接口"><span class="nav-number">18.2.</span> <span class="nav-text">HTMLCollection 接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ParentNode-接口、ChildNode-接口"><span class="nav-number">19.</span> <span class="nav-text">ParentNode 接口、ChildNode 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ParentNode-接口"><span class="nav-number">19.1.</span> <span class="nav-text">ParentNode 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ParentNode-children"><span class="nav-number">19.1.1.</span> <span class="nav-text">ParentNode.children</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParentNode-firstElementChild、ParentNode-lastElementChild"><span class="nav-number">19.1.2.</span> <span class="nav-text">ParentNode.firstElementChild、ParentNode.lastElementChild</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParentNode-append-，ParentNode-prepend"><span class="nav-number">19.1.3.</span> <span class="nav-text">ParentNode.append()，ParentNode.prepend()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ChildNode-接口"><span class="nav-number">19.2.</span> <span class="nav-text">ChildNode 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ChildNode-remove"><span class="nav-number">19.2.1.</span> <span class="nav-text">ChildNode.remove()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChildNode-before-，ChildNode-after"><span class="nav-number">19.2.2.</span> <span class="nav-text">ChildNode.before()，ChildNode.after()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChildNode-replaceWith"><span class="nav-number">19.2.3.</span> <span class="nav-text">ChildNode.replaceWith()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Document-节点"><span class="nav-number">20.</span> <span class="nav-text">Document 节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-2"><span class="nav-number">20.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性-1"><span class="nav-number">20.2.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#document-doctype"><span class="nav-number">20.2.1.</span> <span class="nav-text">document.doctype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#document-body，document-head"><span class="nav-number">20.2.2.</span> <span class="nav-text">document.body，document.head</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#document-documentURI，document-URL"><span class="nav-number">20.2.3.</span> <span class="nav-text">document.documentURI，document.URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#document-location"><span class="nav-number">20.2.4.</span> <span class="nav-text">document.location</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#document-title"><span class="nav-number">20.2.5.</span> <span class="nav-text">document.title</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#document-readyState"><span class="nav-number">20.2.6.</span> <span class="nav-text">document.readyState</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法-1"><span class="nav-number">20.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取元素相关方法"><span class="nav-number">20.3.1.</span> <span class="nav-text">获取元素相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#document-querySelector-，document-querySelectorAll"><span class="nav-number">20.3.1.1.</span> <span class="nav-text">document.querySelector()，document.querySelectorAll()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-getElementsByTagName"><span class="nav-number">20.3.1.2.</span> <span class="nav-text">document.getElementsByTagName()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-getElementsByClassName"><span class="nav-number">20.3.1.3.</span> <span class="nav-text">document.getElementsByClassName()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-getElementById"><span class="nav-number">20.3.1.4.</span> <span class="nav-text">document.getElementById()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-elementFromPoint-，document-elementsFromPoint"><span class="nav-number">20.3.1.5.</span> <span class="nav-text">document.elementFromPoint()，document.elementsFromPoint()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建元素、属性等方法"><span class="nav-number">20.3.2.</span> <span class="nav-text">创建元素、属性等方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#document-createElement"><span class="nav-number">20.3.2.1.</span> <span class="nav-text">document.createElement()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-createTextNode"><span class="nav-number">20.3.2.2.</span> <span class="nav-text">document.createTextNode()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-createAttribute"><span class="nav-number">20.3.2.3.</span> <span class="nav-text">document.createAttribute()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-createComment"><span class="nav-number">20.3.2.4.</span> <span class="nav-text">document.createComment()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-createDocumentFragment"><span class="nav-number">20.3.2.5.</span> <span class="nav-text">document.createDocumentFragment()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-createEvent"><span class="nav-number">20.3.2.6.</span> <span class="nav-text">document.createEvent()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#document-addEventListener-，document-removeEventListener-，document-dispatchEvent"><span class="nav-number">20.3.2.7.</span> <span class="nav-text">document.addEventListener()，document.removeEventListener()，document.dispatchEvent()</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Element-节点"><span class="nav-number">21.</span> <span class="nav-text">Element 节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">21.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例属性"><span class="nav-number">21.2.</span> <span class="nav-text">实例属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元素特性的相关属性"><span class="nav-number">21.2.1.</span> <span class="nav-text">元素特性的相关属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Element-id"><span class="nav-number">21.2.1.1.</span> <span class="nav-text">Element.id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Element-tagName"><span class="nav-number">21.2.1.2.</span> <span class="nav-text">Element.tagName</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Element-title"><span class="nav-number">21.2.1.3.</span> <span class="nav-text">Element.title</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元素状态的相关属性"><span class="nav-number">21.2.2.</span> <span class="nav-text">元素状态的相关属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Element-hidden"><span class="nav-number">21.2.2.1.</span> <span class="nav-text">Element.hidden</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-attributes"><span class="nav-number">21.2.3.</span> <span class="nav-text">Element.attributes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-className，Element-classList"><span class="nav-number">21.2.4.</span> <span class="nav-text">Element.className，Element.classList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-dataset"><span class="nav-number">21.2.5.</span> <span class="nav-text">Element.dataset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-innerHTML"><span class="nav-number">21.2.6.</span> <span class="nav-text">Element.innerHTML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-outerHTML"><span class="nav-number">21.2.7.</span> <span class="nav-text">Element.outerHTML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-clientHeight，Element-clientWidth"><span class="nav-number">21.2.8.</span> <span class="nav-text">Element.clientHeight，Element.clientWidth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-clientLeft，Element-clientTop"><span class="nav-number">21.2.9.</span> <span class="nav-text">Element.clientLeft，Element.clientTop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-scrollHeight，Element-scrollWidth"><span class="nav-number">21.2.10.</span> <span class="nav-text">Element.scrollHeight，Element.scrollWidth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-scrollLeft，Element-scrollTop"><span class="nav-number">21.2.11.</span> <span class="nav-text">Element.scrollLeft，Element.scrollTop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-offsetHeight，Element-offsetWidth"><span class="nav-number">21.2.12.</span> <span class="nav-text">Element.offsetHeight，Element.offsetWidth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-offsetLeft，Element-offsetTop"><span class="nav-number">21.2.13.</span> <span class="nav-text">Element.offsetLeft，Element.offsetTop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-children，Element-childElementCount"><span class="nav-number">21.2.14.</span> <span class="nav-text">Element.children，Element.childElementCount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-firstElementChild，Element-lastElementChild"><span class="nav-number">21.2.15.</span> <span class="nav-text">Element.firstElementChild，Element.lastElementChild</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-nextElementSibling，Element-previousElementSibling"><span class="nav-number">21.2.16.</span> <span class="nav-text">Element.nextElementSibling，Element.previousElementSibling</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例方法"><span class="nav-number">21.3.</span> <span class="nav-text">实例方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性相关方法"><span class="nav-number">21.3.1.</span> <span class="nav-text">属性相关方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-querySelector"><span class="nav-number">21.3.2.</span> <span class="nav-text">Element.querySelector()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-querySelectorAll"><span class="nav-number">21.3.3.</span> <span class="nav-text">Element.querySelectorAll()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-getElementsByClassName"><span class="nav-number">21.3.4.</span> <span class="nav-text">Element.getElementsByClassName()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件相关方法"><span class="nav-number">21.3.5.</span> <span class="nav-text">事件相关方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-scrollIntoView"><span class="nav-number">21.3.6.</span> <span class="nav-text">Element.scrollIntoView()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-remove"><span class="nav-number">21.3.7.</span> <span class="nav-text">Element.remove()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-focus-，Element-blur"><span class="nav-number">21.3.8.</span> <span class="nav-text">Element.focus()，Element.blur()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-click"><span class="nav-number">21.3.9.</span> <span class="nav-text">Element.click()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性的操作"><span class="nav-number">22.</span> <span class="nav-text">属性的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Element-attributes-属性"><span class="nav-number">22.1.</span> <span class="nav-text">Element.attributes 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元素的标准属性"><span class="nav-number">22.2.</span> <span class="nav-text">元素的标准属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性操作的标准方法"><span class="nav-number">22.3.</span> <span class="nav-text">属性操作的标准方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-getAttribute"><span class="nav-number">22.3.1.</span> <span class="nav-text">Element.getAttribute()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-getAttributeNames"><span class="nav-number">22.3.2.</span> <span class="nav-text">Element.getAttributeNames()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-setAttribute"><span class="nav-number">22.3.3.</span> <span class="nav-text">Element.setAttribute()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-hasAttribute"><span class="nav-number">22.3.4.</span> <span class="nav-text">Element.hasAttribute()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-hasAttributes"><span class="nav-number">22.3.5.</span> <span class="nav-text">Element.hasAttributes()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-removeAttribute"><span class="nav-number">22.3.6.</span> <span class="nav-text">Element.removeAttribute()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dataset-属性"><span class="nav-number">22.4.</span> <span class="nav-text">dataset 属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CSS-操作"><span class="nav-number">23.</span> <span class="nav-text">CSS 操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#EventTarget-接口"><span class="nav-number">24.</span> <span class="nav-text">EventTarget 接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件模型"><span class="nav-number">25.</span> <span class="nav-text">事件模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Event-对象"><span class="nav-number">26.</span> <span class="nav-text">Event 对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见事件种类"><span class="nav-number">27.</span> <span class="nav-text">常见事件种类</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Albert Guo"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Albert Guo</p>
  <div class="site-description" itemprop="description">郭鹏松的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:albert-guo@outlook.com" title="E-Mail → mailto:albert-guo@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Albert Guo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
